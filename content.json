{"meta":{"title":"左之右","subtitle":"SamLai'Blog","description":"A Java Programmer,Never To Late...","author":{"name":"samlai","link":"https://github.com/ZuoYouLai"},"url":"https://zuoyoulai.github.io","root":"/"},"pages":[],"posts":[{"title":"java 操作 Es 的 CURD 操作","slug":"java-es","date":"2020-01-29T16:17:10.000Z","updated":"2020-01-30T05:33:17.255Z","comments":true,"path":"2020/01/30/java-es/","link":"","permalink":"https://zuoyoulai.github.io/2020/01/30/java-es/","excerpt":"","text":"java 操作 Es 的 CURD 操作 maven 引入 参考内容 Java 代码 CURD maven 引入123456789101112131415161718192021222324252627&lt;properties&gt; &lt;es.version&gt;6.4.2&lt;&#x2F;es.version&gt;&lt;&#x2F;properties&gt;&lt;dependencies&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.elasticsearch&#x2F;elasticsearch --&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch&lt;&#x2F;groupId&gt; &lt;artifactId&gt;elasticsearch&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;es.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.elasticsearch.client&#x2F;transport --&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;&#x2F;groupId&gt; &lt;artifactId&gt;transport&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;es.version&#125;&lt;&#x2F;version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.elasticsearch&lt;&#x2F;groupId&gt; &lt;artifactId&gt;elasticsearch&lt;&#x2F;artifactId&gt; &lt;&#x2F;exclusion&gt; &lt;&#x2F;exclusions&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; 参考内容 参考文章 : https://www.jianshu.com/p/a584848da515 验证数据 : http://localhost:5601/app/kibana#/dev_tools Java 代码 CURD123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405package com.demo;import com.alibaba.fastjson.JSON;import com.google.common.collect.Maps;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.StringUtils;import org.elasticsearch.action.admin.indices.delete.DeleteIndexResponse;import org.elasticsearch.action.admin.indices.exists.indices.IndicesExistsRequest;import org.elasticsearch.action.admin.indices.exists.indices.IndicesExistsResponse;import org.elasticsearch.action.delete.DeleteResponse;import org.elasticsearch.action.get.GetRequestBuilder;import org.elasticsearch.action.get.GetResponse;import org.elasticsearch.action.index.IndexResponse;import org.elasticsearch.action.search.SearchRequestBuilder;import org.elasticsearch.action.search.SearchResponse;import org.elasticsearch.action.search.SearchType;import org.elasticsearch.action.update.UpdateRequest;import org.elasticsearch.action.update.UpdateResponse;import org.elasticsearch.client.transport.TransportClient;import org.elasticsearch.common.settings.Settings;import org.elasticsearch.common.text.Text;import org.elasticsearch.common.transport.TransportAddress;import org.elasticsearch.index.query.QueryBuilder;import org.elasticsearch.index.query.QueryBuilders;import org.elasticsearch.search.SearchHit;import org.elasticsearch.search.fetch.subphase.highlight.HighlightBuilder;import org.elasticsearch.search.fetch.subphase.highlight.HighlightField;import org.elasticsearch.search.sort.SortOrder;import org.elasticsearch.transport.client.PreBuiltTransportClient;import org.junit.Before;import org.junit.Test;import java.net.InetAddress;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.concurrent.ExecutionException;/** * 参考文章: * https://www.jianshu.com/p/a584848da515 * * es 服务: * http://localhost:9200/ * 来查看 : cluster.name * * kibana 服务: * http://localhost:5601/app/kibana#/dev_tools/console?_g=() * 来验证数据是否正确 */@Slf4jpublic class CurdTest &#123; TransportClient transportClient = null; private final static String hostName = \"localhost\"; private final static Integer port = 9300; private final static Integer poolSize = 5; private final static String index = \"db-1\"; private final static String type = \"tab-1\"; @Before public void init() &#123; try &#123; // 配置信息 Settings esSetting = Settings.builder() .put(\"cluster.name\", \"docker-cluster\") //集群名字// .put(\"client.transport.sniff\", true)//增加嗅探机制，找到ES集群 .put(\"thread_pool.search.size\", poolSize)//增加线程池个数，暂时设为5 .build(); //配置信息Settings自定义 transportClient = new PreBuiltTransportClient(esSetting); TransportAddress transportAddress = new TransportAddress(InetAddress.getByName(hostName), port); transportClient.addTransportAddresses(transportAddress); &#125; catch (Exception e) &#123; log.error(\"elasticsearch TransportClient create error!!\", e); &#125; &#125; /** * 新增操作 */ @Test public void oneInsert() &#123; String data = \"&#123;\\n\" + \" \\\"cn-name\\\":\\\"java 赖\\\",\\n\" + \" \\\"en-name\\\":\\\"java es lai\\\",\\n\" + \" \\\"age\\\":28,\\n\" + \" \\\"content\\\":\\\"code 操作....\\\"\\n\" + \"&#125;\"; //这个版本需要把 json 字符串转为 map 对象 不然会报错 Map map = JSON.parseObject(data, Map.class); IndexResponse response = transportClient.prepareIndex(index, type).setSource(map).get(); log.info(\"addData response status:&#123;&#125;,id:&#123;&#125;\", response.status().getStatus(), response.getId()); &#125; /** * 批量的插入的操作 */ @Test public void batchInsert() &#123; BulkRequestBuilder bulkRequest = transportClient.prepareBulk(); for (int i = 60; i &lt; 100; i++) &#123; Map map = Maps.newHashMap(); map.put(\"cn-name\", \"00\" + i); map.put(\"en-name\", \"java samlai\" + i); map.put(\"age\", 10 + i); map.put(\"content\", \" 内容 --&gt;\" + i); IndexRequest request = transportClient.prepareIndex(index, type, String.valueOf(i)).setSource(map).request(); bulkRequest.add(request); &#125; bulkRequest.execute().actionGet(); &#125; /** * 删除操作 */ @Test public void del() &#123; String id = \"dpcY7G8BVtcun_3JK7HX\"; DeleteResponse response = transportClient.prepareDelete(index, type, id).execute().actionGet(); log.info(\"deleteDataById response status:&#123;&#125;,id:&#123;&#125;\", response.status().getStatus(), response.getId()); &#125; /** * 删除 index 操作 * */ @Test public void delIndex() &#123; if (!isIndexExist(transportClient, index)) &#123; log.info(\"Index is not exits!\"); &#125; DeleteIndexResponse dResponse = transportClient.admin().indices().prepareDelete(index).execute().actionGet(); if (dResponse.isAcknowledged()) &#123; log.info(\"delete index \" + index + \" successfully!\"); &#125; else &#123; log.info(\"Fail to delete index \" + index); &#125;// return dResponse.isAcknowledged(); log.info(\"del Index : \" + dResponse.isAcknowledged()); &#125; /** * 修改操作 */ @Test public void update() throws ExecutionException, InterruptedException &#123; String data = \"&#123;\\n\" +// \" \\\"cn-name\\\":\\\"java 赖 update\\\"\\n\" + \" \\\"cn-name\\\":\\\"java 赖 update\\\",\\n\" + \" \\\"en-name\\\":\\\"java es lai ipdate\\\",\\n\" + \" \\\"age\\\":13,\\n\" + \" \\\"content\\\":\\\"update content\\\"\\n\" + \"&#125;\"; String id = \"d5dG7G8BVtcun_3JnrGp\"; //这个版本需要把 json 字符串转为 map 对象 不然会报错 Map map = JSON.parseObject(data, Map.class); UpdateRequest updateRequest = new UpdateRequest(); updateRequest.index(index).type(type).id(id).doc(map); transportClient.update(updateRequest); UpdateResponse result = transportClient.update(updateRequest).get(); // 默认情况下，不更改任何内容的更新会检测到它们不会更改任何内容，并返回“结果”：“noop” log.info(\"\"); log.info(\" result : \" + JSON.toJSONString(result)); log.info(\" update data ： \" + JSON.toJSONString(result.getResult())); log.info(\"\"); &#125; /** * 根据 id 来查找 es 的数据内容 */ @Test public void queryId() &#123; String id = \"d5dG7G8BVtcun_3JnrGp\"; String fields = \"\"; GetRequestBuilder getRequestBuilder = transportClient.prepareGet(index, type, id); if (StringUtils.isNotEmpty(fields)) &#123; getRequestBuilder.setFetchSource(fields.split(\",\"), null); &#125; GetResponse getResponse = getRequestBuilder.execute().actionGet(); log.info(\"\"); log.info(\" reponse data : \" + JSON.toJSONString(getResponse)); log.info(\" data : \" + getResponse.getSource()); log.info(\"\"); &#125; /** * 使用分词查询,并分页 * * @param index 索引名称 * @param type 类型名称,可传入多个type逗号分隔 * @param startPage 当前页 * @param pageSize 每页显示条数 * @param query 查询条件 * @param fields 需要显示的字段，逗号分隔（缺省为全部字段） * @param sortField 排序字段 * @param highlightField 高亮字段 * @return */ @Test public void queryPage() &#123; SearchRequestBuilder searchRequestBuilder = transportClient.prepareSearch(index); String fields = \"content,en-name\"; String sortField = \"age\"; String highlightField = \"content\";// String highlightField = \"cn-name\"; QueryBuilder query = QueryBuilders.boolQuery(); int startPage = 1; int pageSize = 10; if (StringUtils.isNotEmpty(type)) &#123; searchRequestBuilder.setTypes(type.split(\",\")); &#125; searchRequestBuilder.setSearchType(SearchType.QUERY_THEN_FETCH); // 需要显示的字段，逗号分隔（缺省为全部字段） if (StringUtils.isNotEmpty(fields)) &#123; searchRequestBuilder.setFetchSource(fields.split(\",\"), null); &#125; //排序字段 if (StringUtils.isNotEmpty(sortField)) &#123; searchRequestBuilder.addSort(sortField, SortOrder.DESC); &#125; // 高亮（xxx=111,aaa=222） if (StringUtils.isNotEmpty(highlightField)) &#123; HighlightBuilder highlightBuilder = new HighlightBuilder(); highlightBuilder.preTags(\"&lt;span style='color:red' &gt;\");//设置前缀 highlightBuilder.postTags(\"&lt;/span&gt;\");//设置后缀 // 设置高亮字段 highlightBuilder.field(highlightField); searchRequestBuilder.highlighter(highlightBuilder); &#125; //searchRequestBuilder.setQuery(QueryBuilders.matchAllQuery()); searchRequestBuilder.setQuery(query); // 分页应用 searchRequestBuilder.setFrom(startPage).setSize(pageSize); // 设置是否按查询匹配度排序 searchRequestBuilder.setExplain(true); //打印的内容 可以在 Elasticsearch head 和 Kibana 上执行查询 log.info(\"\\n&#123;&#125;\", searchRequestBuilder); // 执行搜索,返回搜索响应信息 SearchResponse searchResponse = searchRequestBuilder.execute().actionGet(); long totalHits = searchResponse.getHits().totalHits; long length = searchResponse.getHits().getHits().length; log.info(\"共查询到[&#123;&#125;]条数据,处理数据条数[&#123;&#125;]\", totalHits, length); if (searchResponse.status().getStatus() == 200) &#123; // 解析对象 List&lt;Map&lt;String, Object&gt;&gt; sourceList = setSearchResponse(searchResponse, highlightField); log.info(\" \"); log.info(\" startPage : \" + startPage); log.info(\" pageSize : \" + pageSize); log.info(\" totalHits : \" + totalHits); log.info(\" sourceList : \" + JSON.toJSONString(sourceList)); log.info(\" \"); &#125; &#125; /** * 判断索引是否存在 * * @param index * @return */ public static boolean isIndexExist(TransportClient transportClient, String index) &#123; IndicesExistsResponse inExistsResponse = transportClient.admin().indices().exists(new IndicesExistsRequest(index)).actionGet(); if (inExistsResponse.isExists()) &#123; log.info(\"Index [\" + index + \"] is exist!\"); &#125; else &#123; log.info(\"Index [\" + index + \"] is not exist!\"); &#125; return inExistsResponse.isExists(); &#125; /** * @Description: 判断inde下指定type是否存在 */ public boolean isTypeExist(TransportClient transportClient, String index, String type) &#123; return isIndexExist(transportClient, index) ? transportClient.admin().indices().prepareTypesExists(index).setTypes(type).execute().actionGet().isExists() : false; &#125; /** * 高亮结果集 特殊处理 * * @param searchResponse * @param highlightField */ private static List&lt;Map&lt;String, Object&gt;&gt; setSearchResponse(SearchResponse searchResponse, String highlightField) &#123; List&lt;Map&lt;String, Object&gt;&gt; sourceList = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(); StringBuffer stringBuffer = new StringBuffer(); for (SearchHit searchHit : searchResponse.getHits().getHits()) &#123; searchHit.getSourceAsMap().put(\"id\", searchHit.getId()); if (StringUtils.isNotEmpty(highlightField)) &#123; log.info(\"遍历 高亮结果集，覆盖 正常结果集\" + searchHit.getSourceAsMap()); HighlightField field = searchHit.getHighlightFields().get(highlightField); if (field != null) &#123; Text[] text = field.getFragments(); if (text != null) &#123; for (Text str : text) &#123; stringBuffer.append(str.string()); &#125; //遍历 高亮结果集，覆盖 正常结果集 searchHit.getSourceAsMap().put(highlightField, stringBuffer.toString()); &#125; &#125; &#125; sourceList.add(searchHit.getSourceAsMap()); &#125; return sourceList; &#125;&#125;","categories":[{"name":"elk","slug":"elk","permalink":"https://zuoyoulai.github.io/categories/elk/"}],"tags":[{"name":"elk","slug":"elk","permalink":"https://zuoyoulai.github.io/tags/elk/"},{"name":"java","slug":"java","permalink":"https://zuoyoulai.github.io/tags/java/"}],"author":{"nick":"samlai","link":"https://github.com/ZuoYouLai"}},{"title":"xxx-job 分布式定时任务系统","slug":"xxx-job","date":"2020-01-28T04:09:50.000Z","updated":"2020-01-29T16:21:53.399Z","comments":true,"path":"2020/01/28/xxx-job/","link":"","permalink":"https://zuoyoulai.github.io/2020/01/28/xxx-job/","excerpt":"","text":"xxx-job 分布式定时任务系统 来源 环境准备 ### 来源 官方文档 : https://www.xuxueli.com/index.html 环境准备 docker镜像 1docker pull xuxueli&#x2F;xxl-job-admin:2.1.2 ip地址查看 12~ » ifconfig | grep &quot;inet &quot; | grep -v 127.0.0.1 haodalai@localhost inet 192.168.31.164 netmask 0xffffff00 broadcast 192.168.31.255 启动docker 镜像 1docker run -e PARAMS&#x3D;&quot;--spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;192.168.31.164:3307&#x2F;xxl_job?Unicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8 --spring.datasource.password&#x3D;samlai123&quot; -p 8787:8080 -v &#x2F;Users&#x2F;haodalai&#x2F;docker&#x2F;xxx-job&#x2F;logs:&#x2F;data&#x2F;applogs --name xxl-job-admin -d xuxueli&#x2F;xxl-job-admin:2.1.2 访问地址 : http://localhost:8787/xxl-job-admin 访问的账号与密码: admin/123456","categories":[{"name":"分布式定时任务系统","slug":"分布式定时任务系统","permalink":"https://zuoyoulai.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"分布式定时任务系统","slug":"分布式定时任务系统","permalink":"https://zuoyoulai.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/"},{"name":"xxx-job","slug":"xxx-job","permalink":"https://zuoyoulai.github.io/tags/xxx-job/"}],"author":{"nick":"samlai","link":"https://github.com/ZuoYouLai"}},{"title":"docker 部署使用 ELk","slug":"elk","date":"2020-01-27T15:47:27.000Z","updated":"2020-01-30T15:31:38.490Z","comments":true,"path":"2020/01/27/elk/","link":"","permalink":"https://zuoyoulai.github.io/2020/01/27/elk/","excerpt":"","text":"docker 部署使用 ELk 基础 : 拉取镜像 集成:ELK 访问服务 kibana 操作 Es 增删该查操作 概念 kibana 对 es 增删改查 Es 查询分类 : query string search / query DSL full-text search 全文检索 | phrase search 短语搜索 Es 核心的操作还是查询操作: 使用query DSL 请求查询 基础 : 拉取镜像123docker pull elasticsearch:6.5.4docker pull kibana:6.5.4docker pull logstash:6.5.4 集成:ELK 工具: docker-compose 版本的指定: 在 compose 文件下有.env 文件写上相应的版本号内容1ELK_VERSION&#x3D;6.5.4 compose 文件内容123456789101112131415161718192021222324252627282930313233343536373839404142434445version: &#39;2&#39;services: elasticsearch: image: &quot;elasticsearch:$&#123;ELK_VERSION&#125;&quot; container_name: elasticsearch ports: - &quot;9200:9200&quot; - &quot;9300:9300&quot; environment: ES_JAVA_OPTS: &quot;-Xmx1024m -Xms1024m&quot; #command: [&quot;bash&quot;, &quot;-c&quot;, &quot;echo &#39;discovery.type: single-node&#39;&gt;&gt;&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;config&#x2F;elasticsearch.yml; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-entrypoint.sh eswrapper&quot;] command: [&quot;bash&quot;, &quot;-c&quot;, &quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-entrypoint.sh eswrapper&quot;] networks: - elk logstash: image: &quot;logstash:$&#123;ELK_VERSION&#125;&quot; container_name: logstash volumes: - .&#x2F;logstash&#x2F;pipeline:&#x2F;usr&#x2F;share&#x2F;logstash&#x2F;pipeline:ro ports: - &quot;5000:5000&quot; environment: LS_JAVA_OPTS: &quot;-Xmx256m -Xms256m&quot; depends_on: - elasticsearch command: [&quot;bash&quot;, &quot;-c&quot;, &quot;echo &#39;path.config: &#x2F;usr&#x2F;share&#x2F;logstash&#x2F;pipeline&#39;&gt;&gt;&#x2F;usr&#x2F;share&#x2F;logstash&#x2F;config&#x2F;logstash.yml; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-entrypoint&quot;] networks: - elk kibana: image: &quot;kibana:$&#123;ELK_VERSION&#125;&quot; container_name: kibana ports: - &quot;5601:5601&quot; depends_on: - elasticsearch networks: - elknetworks: elk: driver: bridge 访问服务 访问 Es : http://localhost:9200/ 访问 kibana : http://localhost:5601 121. 打开dev Tools2. 在窗口进行查询 : GET &#x2F;_search kibana 操作 Es 增删该查操作概念 类比: 12Relational DB -&gt; Databases -&gt; Tables -&gt; Rows -&gt; ColumnsElasticsearch -&gt; Indices -&gt; Types -&gt; Documents -&gt; Fields kibana 对 es 增删改查 概念文档: http://blog.didispace.com/books/elasticsearch-definitive-guide-cn/010_Intro/00_README.html 例子文档: https://blog.csdn.net/u014646662/category_8747782_2.html 查看集群健康信息 1234567GET &#x2F;_cat&#x2F;health?vGreen（正常）Yellow（正常，但是一些副本还没有分配）Red（非正常） 查看集群，索引，分片情况: 12GET &#x2F;_cat&#x2F;indices?v&amp;h&#x3D;health,status,index 查看查询全部内容 12GET &#x2F;_search 增加一个 document 内容,格式 : POST /{index}/{type} 不加 id 则系统默认给出一个 id 12345678910111213141516171819202122232425262728293031323334353637383940POST &#x2F;db-1&#x2F;tab-1&#123; &quot;cn-name&quot;:&quot;赖豪达&quot;, &quot;en-name&quot;:&quot;samlai&quot;, &quot;age&quot;:28, &quot;content&quot;:&quot;我的简介操作....&quot;&#125;返回的结果:&#123; &quot;_index&quot; : &quot;db-1&quot;, &quot;_type&quot; : &quot;tab-1&quot;, &quot;_id&quot; : &quot;dZc56m8BVtcun_3JvbEQ&quot;, &quot;_version&quot; : 1, &quot;result&quot; : &quot;created&quot;, &quot;_shards&quot; : &#123; &quot;total&quot; : 2, &quot;successful&quot; : 1, &quot;failed&quot; : 0 &#125;, &quot;_seq_no&quot; : 1, &quot;_primary_term&quot; : 1&#125;or 自己指定一个 id :POST &#x2F;db-1&#x2F;tab-1&#x2F;1&#123; &quot;cn-name&quot;:&quot;赖豪达&quot;, &quot;en-name&quot;:&quot;samlai&quot;, &quot;age&quot;:28, &quot;content&quot;:&quot;我的简介操作....&quot;&#125; 删除一个 document 内容: DELETE /{index}/{type}/{id} 12DELETE db-1&#x2F;tab-1&#x2F;dJcs6m8BVtcun_3JbrGq 修改的操作,分覆盖全部 与 修改某些字段: 123456789101112131415161718192021222324252627282930313233343536373839401. 覆盖全部字段:PUT &#x2F;db-1&#x2F;tab-1&#x2F;2&#123; &quot;cn-name&quot;:&quot;赖豪达0002 修改---&quot;, &quot;en-name&quot;:&quot;samlai0002&quot;, &quot;age&quot;:28, &quot;content&quot;:&quot;我的简介操作....0002&quot;&#125;2.修改某些字段内容:POST db-1&#x2F;tab-1&#x2F;1&#x2F;_update&#123; &quot;doc&quot;: &#123; &quot;en-name&quot;:&quot;我的英文名字是:赖豪达&quot; &#125;&#125;返回结果:&#123; &quot;_index&quot; : &quot;db-1&quot;, &quot;_type&quot; : &quot;tab-1&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_version&quot; : 2, &quot;result&quot; : &quot;noop&quot;, &quot;_shards&quot; : &#123; &quot;total&quot; : 0, &quot;successful&quot; : 0, &quot;failed&quot; : 0 &#125;&#125; 查询一个 document 内容 : GET /{index}/{type}/{id} 1234567891011121314151617181920212223242526272829303132331.GET db-1&#x2F;tab-1&#x2F;dJcs6m8BVtcun_3JbrGq返回结果:&#123; &quot;_index&quot; : &quot;db-1&quot;, &quot;_type&quot; : &quot;tab-1&quot;, &quot;_id&quot; : &quot;dZc56m8BVtcun_3JvbEQ&quot;, &quot;_version&quot; : 1, &quot;found&quot; : true, &quot;_source&quot; : &#123; &quot;cn-name&quot; : &quot;赖豪达&quot;, &quot;en-name&quot; : &quot;samlai&quot;, &quot;age&quot; : 28, &quot;content&quot; : &quot;我的简介操作....&quot; &#125;&#125;2.GET db-1&#x2F;tab-1&#x2F;dJcs6m8BVtcun_3JbrGq&#x2F;_source返回结果:&#123; &quot;cn-name&quot; : &quot;赖豪达&quot;, &quot;en-name&quot; : &quot;samlai&quot;, &quot;age&quot; : 28, &quot;content&quot; : &quot;我的简介操作....&quot;&#125; Es 查询分类 : query string search / query DSL123456789101112131415161718第一种：类似搜索全部商品： GET &#x2F;ecommerce&#x2F;product&#x2F;_search (参数直接拼接在请求上，不带json参数的) query string search的由来，因为search参数都是以http请求的query string来附带的。 搜索商品名称中包含yagao的商品，而且按照售价降序排列： GET &#x2F;ecommerce&#x2F;product&#x2F;_search?q&#x3D;name:yagao&amp;sort&#x3D;price:desc 适用于临时的在命令行使用一些工具，比如curl，快速的发出请求，来检索想要的信息；但是 如果查询请求很复杂，是很难去构建的，所以在生产环境中，几乎很少使用query string search。 第二种：DSL：Domain Specified Language,特定领域的语言 http request body:请求体，可以用json的格式来构建查询语法，比较方便，可以构建各种复杂的语法， 比query string search肯定强大太多了。 full-text search 全文检索 | phrase search 短语搜索123456全文检索:会将输入的搜索串拆解开来，去索引里面去一一匹配，只要能匹配任意一个拆解后的单词，就可以作为结果返回短语搜索:要求输入的搜索串，必须在指定的字段文本中，完全包含一模一样的，才可以算匹配成功，才能作为结果返回 多条件查询中的字段描述 1234567891011must： 表示一定要满足； should： 表示可以满足也可以不满足； must_not： 表示不能满足该条件； minimum_should_match:1 ：表示最小匹配度，可以设置为百分之百，设置了这个值的时候就必须满足should里面的设置了， 另外注意这边should里面同一字段设置的多个值，意思是当这个值等于X或者等于Y都成立，务必注意格式。 Es 核心的操作还是查询操作: 使用query DSL 请求查询 参考文章 : https://www.cnblogs.com/liuqijia/p/11507494.html match 分页查询: 12345678GET db-1&#x2F;tab-1&#x2F;_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot; : &#123;&#125; &#125;, &quot;from&quot;: 0, &quot;size&quot;: 1&#125; 根据字段 age 的倒序的查询: 1234567891011GET db-1&#x2F;tab-1&#x2F;_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot; : &#123;&#125; &#125;, &quot;sort&quot;: [ &#123; &quot;age&quot;: &quot;desc&quot; &#125; ]&#125; 指定查询项 : 只查询出 content 的字段内容: 123456789GET db-1&#x2F;tab-1&#x2F;_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot; : &#123;&#125; &#125;, &quot;_source&quot;: &quot;content&quot;, &quot;from&quot;: 0, &quot;size&quot;: 1&#125; matchAll 操作: 全查询 但显示仅仅是 5条记录 1234567891011121314151617181920212223242526272829303132GET db-1&#x2F;tab-1&#x2F;_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot; : &#123;&#125; &#125;&#125;返回结果: 5条记录&#96;&#96;&#96; + 过滤查询 : 匹配查询 cn-name &#x3D; ELK &#96;&#96;&#96;textGET db-1&#x2F;tab-1&#x2F;_search&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;must&quot;: [ &#123; &quot;match&quot;: &#123; &quot;cn-name&quot;: &quot;ELK&quot; &#125; &#125; ] &#125; &#125;&#125; 全文检索:12345678GET db-1&#x2F;tab-1&#x2F;_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;content&quot;: &quot;97&quot; &#125; &#125;&#125; 短语检索:12345678GET db-1&#x2F;tab-1&#x2F;_search&#123; &quot;query&quot;: &#123; &quot;match_phrase&quot;: &#123; &quot;content&quot;: &quot; 内容 --&gt;9&quot; &#125; &#125;&#125;","categories":[{"name":"elk","slug":"elk","permalink":"https://zuoyoulai.github.io/categories/elk/"}],"tags":[{"name":"elk","slug":"elk","permalink":"https://zuoyoulai.github.io/tags/elk/"},{"name":"docker","slug":"docker","permalink":"https://zuoyoulai.github.io/tags/docker/"}],"author":{"nick":"samlai","link":"https://github.com/ZuoYouLai"}},{"title":"mybatis-batch 批处理","slug":"mybatis-batch","date":"2020-01-22T07:27:01.000Z","updated":"2020-01-22T07:40:34.345Z","comments":true,"path":"2020/01/22/mybatis-batch/","link":"","permalink":"https://zuoyoulai.github.io/2020/01/22/mybatis-batch/","excerpt":"","text":"批量处理方式 以上3种的优劣: 例子demo 批量处理方式 原生的JDBC : 这种方式最快，代码比较麻烦 Mybatis 的 ExecutorType.BATCH ：代码编写比较简单，数据库连接需要添加allowMultiQueries=true Mybatis 动态 sql拼接方式 以上3种的优劣: 参考文章: 关于Mybatis批量插入使用JDBC原生batch批处理以及mybatis的ExecutorType.BATCH的批处理和Mybatis的动态sql语句批处理 例子demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/** * batch insert * 表数据准备 * create table `kt_1_trigger_logs` like kt_merchant_id_trigger_logs; * * 批量处理 : 添加 200w条数据 */ @Test public void batch() &#123; try &#123; SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH); SubMerchantIdTriggerLogsMapper subMerchantIdTriggerLogsMapper = (SubMerchantIdTriggerLogsMapper) sqlSession.getMapper(SubMerchantIdTriggerLogsMapper.class); for (int j = 0; j &lt; 200; j++) &#123; for (int i = 0; i &lt; 1000; i++) &#123; SubMerchantIdTriggerLogs logs = new SubMerchantIdTriggerLogs(); logs.setAppId(appId); logs.setMerchantId(merchantId); logs.setSdkType(test_str); logs.setSource(test_str); logs.setTriggeredAt(new Date()); logs.setUserid(Tools.getRandStr()); logs.setDeviceid(Tools.getRandStr(5)); logs.setConditions(\"\"); if (i % 2 == 0) &#123; logs.setIp(Tools.getRandStr(5)); logs.setUpdatedAt(new Date()); &#125; else &#123; logs.setIp(\"\"); &#125; logs.setCreatedAt(new Date()); subMerchantIdTriggerLogsMapper.insertSelective(logs); &#125; sqlSession.commit(); &#125; sqlSession.close(); &#125; catch (Exception ex) &#123; log.error(ex.getMessage(), ex); &#125; &#125; /** * batch update * 批量的 update 的操作 : 校验出，有些字段有有些没有的话则相应的更新的 * */ @Test public void batchUpdate() &#123; try &#123; SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH); SubMerchantIdTriggerLogsMapper subMerchantIdTriggerLogsMapper = (SubMerchantIdTriggerLogsMapper) sqlSession.getMapper(SubMerchantIdTriggerLogsMapper.class); for (int i = 0; i &lt; 10; i++) &#123; SubMerchantIdTriggerLogs subMerchantIdTriggerLogs = new SubMerchantIdTriggerLogs(); subMerchantIdTriggerLogs.setMerchantId(merchantId); subMerchantIdTriggerLogs.setId(i); if (i % 2 == 0) &#123; subMerchantIdTriggerLogs.setIp(\"\"); subMerchantIdTriggerLogs.setSdkVersion(\"\"); &#125; subMerchantIdTriggerLogs.setUpdatedAt(new Date()); subMerchantIdTriggerLogsMapper.updateByPrimaryKeySelective(subMerchantIdTriggerLogs); &#125; sqlSession.commit(); sqlSession.close(); &#125;catch (Exception ex) &#123; log.error(ex.getMessage(), ex); &#125; &#125; /** * 批量更新后的操作断言 */ @Test public void updateAfterDo() &#123; try &#123; SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH,Boolean.FALSE); SubMerchantIdTriggerLogsMapper subMerchantIdTriggerLogsMapper = (SubMerchantIdTriggerLogsMapper) sqlSession.getMapper(SubMerchantIdTriggerLogsMapper.class); List&lt;SubMerchantIdTriggerLogs&gt; list = Lists.newArrayList(); for (int i = 0; i &lt; 10; i++) &#123; SubMerchantIdTriggerLogs logs = new SubMerchantIdTriggerLogs(); logs.setAppId(appId); logs.setMerchantId(merchantId); logs.setSdkType(test_str); logs.setSource(test_str); logs.setTriggeredAt(new Date()); logs.setUserid(Tools.getRandStr()); logs.setDeviceid(Tools.getRandStr(5)); logs.setConditions(\"\"); if (i % 2 == 0) &#123; logs.setIp(Tools.getRandStr(5)); logs.setUpdatedAt(new Date()); &#125; else &#123; logs.setIp(\"\"); &#125; logs.setCreatedAt(new Date()); list.add(logs); subMerchantIdTriggerLogsMapper.insertSelective(logs); &#125; sqlSession.commit(); //刷新执行结果可以进行断言操作 [发现有无这个执行都可以拿到新增 insert data 的 id 的]// sqlSession.flushStatements(); //清除缓存// sqlSession.clearCache(); sqlSession.close(); list.forEach(x-&gt;&#123; log.info(JSON.toJSONString(x)); &#125;); list.clear(); &#125; catch (Exception ex) &#123; log.error(ex.getMessage(), ex); &#125; &#125;","categories":[{"name":"mybatis","slug":"mybatis","permalink":"https://zuoyoulai.github.io/categories/mybatis/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://zuoyoulai.github.io/tags/mybatis/"},{"name":"sql","slug":"sql","permalink":"https://zuoyoulai.github.io/tags/sql/"}],"author":{"nick":"samlai","link":"https://github.com/ZuoYouLai"}},{"title":"运维Redis服务信息","slug":"Redis服务信息","date":"2020-01-13T14:30:59.000Z","updated":"2020-01-13T14:38:45.897Z","comments":true,"path":"2020/01/13/Redis服务信息/","link":"","permalink":"https://zuoyoulai.github.io/2020/01/13/Redis%E6%9C%8D%E5%8A%A1%E4%BF%A1%E6%81%AF/","excerpt":"","text":"运维Redis服务信息 redis 队列消费问题 数据表的准备 系统 redis 配置 redis 连接池基本配置说明 进入 redis 的容器的指令操作 redis 队列消费问题 参考文章: https://mp.weixin.qq.com/s/4DYdDEHpiLs8aoW6y9k4Mw 数据表的准备12345create table &#96;xx_tbl&#96; like model_tbl;example:create table &#96;xx_tbl&#96; like model_tbl; 系统 redis 配置123456789#rdb backupsave 300 10#aof backup#是否开启持久化策略appendonly yes#yes: 在aof重写期间不做fsync刷盘操作，可能丢失整个AOF重写期间的数据no-appendfsync-on-rewrite yes redis 连接池基本配置说明 redis.pool.maxTotal=1000 : 最大活动对象数 redis.pool.maxIdle=100 最大能够保持idel状态的对象数 redis.pool.minIdle=50 最小能够保持idel状态的对象数 进入 redis 的容器的指令操作 docker ps docker exec -it [containerid] /bin/bash docker exec -it [containerid] redis-cli -a root 1234567docker exec -it 77ae redis-cli进入指令窗口,进行 root 操作:&gt;&gt; auth [your password]进入指令操作:docker exec -it 77ae redis-cli -a root 监控redis的磁盘使用情况与 clients 的连接数: redis-cli –stat -i 10 1234567&gt;&gt; docker exec -it 77ae redis-cli -a root --stat -i 10 [不安全的写法,因为密码写在明文上]打出指令进行监控的操作,定时的刷出日志内容: 【单位是: 10s】------- data ------ --------------------- load -------------------- - child -keys mem clients blocked requests connections 11 5.55M 3 0 312130 (+917) 690 查看 redis 某个节点的网络延迟: redis-cli –latentcy -h 127.0.0.1 12345&gt;&gt; docker exec -it 77ae redis-cli -a root --latency -h 127.0.0.1min: 0, max: 7, avg: 0.25 (15009 samples)avg：0.25，即延迟为250μs。如果通过外网连接网络延迟会很高，比如跨机房的redis调用，延迟高的情况下使用redis反而比使用本地硬盘读写性能更差 命令指令12345678key &#x3D; trigger_log_list查看链表的长度:&gt;&gt; llen trigger_log_list查看链表的数据:&gt;&gt; lrange trigger_log_list 0 10 监控的指令操作 查看 redis 当前的连接数 : info clients 1234567891011# Clientsconnected_clients:12client_recent_max_input_buffer:2client_recent_max_output_buffer:0blocked_clients:0&#96;&#96;&#96; + 查询redis允许的最大连接数 : config get maxclients&#96;&#96;&#96;text1) &quot;maxclients&quot;2) &quot;10000&quot; 每秒处理的命令数: info stats 12345678910111213141516171819202122232425262728&gt;&gt; info stats# Statstotal_connections_received:1total_commands_processed:2instantaneous_ops_per_sec:0total_net_input_bytes:129total_net_output_bytes:135instantaneous_input_kbps:0.00instantaneous_output_kbps:0.00rejected_connections:0sync_full:0sync_partial_ok:0sync_partial_err:0expired_keys:313904035720expired_stale_perc:0.00expired_time_cap_reached_count:0evicted_keys:0keyspace_hits:1keyspace_misses:0pubsub_channels:0pubsub_patterns:0latest_fork_usec:0migrate_cached_sockets:0slave_expires_tracked_keys:0active_defrag_hits:0active_defrag_misses:0active_defrag_key_hits:0active_defrag_key_misses:0 慢日志的查询 : slowlog get 可通过config set slowlog-log-slower-than xxx修改慢查询时间，单位微秒，默认情况下，这个值为10000 12345678910127.0.0.1:6379&gt; slowlog get1) 1) (integer) 0 2) (integer) 1578658649 3) (integer) 15696 4) 1) &quot;LRANGE&quot; 2) &quot;trigger_log_list_0&quot; 3) &quot;0&quot; 4) &quot;999&quot; 5) &quot;172.17.0.1:51742&quot; 6) &quot;&quot;","categories":[{"name":"Redis","slug":"Redis","permalink":"https://zuoyoulai.github.io/categories/Redis/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://zuoyoulai.github.io/tags/Docker/"},{"name":"Redis","slug":"Redis","permalink":"https://zuoyoulai.github.io/tags/Redis/"},{"name":"运维","slug":"运维","permalink":"https://zuoyoulai.github.io/tags/%E8%BF%90%E7%BB%B4/"}],"author":{"nick":"samlai","link":"https://github.com/ZuoYouLai"}},{"title":"线上系统运行信息查看 shell 脚本","slug":"线上系统运行信息查看","date":"2020-01-09T10:41:03.000Z","updated":"2020-01-09T10:53:20.669Z","comments":true,"path":"2020/01/09/线上系统运行信息查看/","link":"","permalink":"https://zuoyoulai.github.io/2020/01/09/%E7%BA%BF%E4%B8%8A%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E4%BF%A1%E6%81%AF%E6%9F%A5%E7%9C%8B/","excerpt":"","text":"线上系统运行信息查看 shell 脚本1234567891011121314#!&#x2F;bin&#x2F;bashproject_path&#x3D;&quot;&#x2F;Users&#x2F;haodalai&#x2F;go&quot;echo &quot;显示系统磁盘分布情况&quot;echo &quot;&quot;df -hecho &quot;&quot;echo &quot;&quot;echo &quot;显示文件或目录占用情况&quot;echo &quot;&quot;du -sh $project_path","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zuoyoulai.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zuoyoulai.github.io/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://zuoyoulai.github.io/tags/Shell/"}],"author":{"nick":"samlai","link":"https://github.com/ZuoYouLai"}},{"title":"每天学习一个 Linux 指令 - du 与 df 指令","slug":"Linux-Du-Df","date":"2020-01-09T06:28:10.000Z","updated":"2020-01-09T10:39:59.858Z","comments":true,"path":"2020/01/09/Linux-Du-Df/","link":"","permalink":"https://zuoyoulai.github.io/2020/01/09/Linux-Du-Df/","excerpt":"","text":"Linux的 du 与 df 指令 df 指令 du 指令 df 指令 df命令用于显示目前在Linux系统上的文件系统的磁盘使用情况统计 格式 : df [选项]… [FILE]… 经常使用: df -h 12345678910111213141516171819202122232425262728293031323334文件-a, --all 包含所有的具有 0 Blocks 的文件系统文件--block-size&#x3D;&#123;SIZE&#125; 使用 &#123;SIZE&#125; 大小的 Blocks文件-h, --human-readable 使用人类可读的格式(预设值是不加这个选项的...)文件-H, --si 很像 -h, 但是用 1000 为单位而不是用 1024文件-i, --inodes 列出 inode 资讯，不列出已使用 block文件-k, --kilobytes 就像是 --block-size&#x3D;1024文件-l, --local 限制列出的文件结构文件-m, --megabytes 就像 --block-size&#x3D;1048576文件--no-sync 取得资讯前不 sync (预设值)文件-P, --portability 使用 POSIX 输出格式文件--sync 在取得资讯前 sync文件-t, --type&#x3D;TYPE 限制列出文件系统的 TYPE文件-T, --print-type 显示文件系统的形式文件-x, --exclude-type&#x3D;TYPE 限制列出文件系统不要显示 TYPE文件-v (忽略)文件--help 显示这个帮手并且离开文件--version 输出版本资讯并且离开 du 指令 du命令用于显示文件或目录所占用的磁盘空间 格式 : du [option] 文件/目录 常用 :123du -sh xxx 显示总目录的大小，但是不会列出目录中的每一个文件du -sh xxx&#x2F;* 列出xxx下每个目录和文件所占的容量du -h --max-depth&#x3D;1 Linux 查找占用空间最大的文件与目录 123456789101112131415161718192021222324252627282930313233343536-a或-all 显示目录中个别文件的大小。-b或-bytes 显示目录或文件大小时，以byte为单位。-c或--total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。-D或--dereference-args 显示指定符号连接的源文件大小。-h或--human-readable 以K，M，G为单位，提高信息的可读性。-H或--si 与-h参数相同，但是K，M，G是以1000为换算单位。-k或--kilobytes 以1024 bytes为单位。-l或--count-links 重复计算硬件连接的文件。-L&lt;符号连接&gt;或--dereference&lt;符号连接&gt; 显示选项中所指定符号连接的源文件大小。-m或--megabytes 以1MB为单位。-s或--summarize 仅显示总计。-S或--separate-dirs 显示个别目录的大小时，并不含其子目录的大小。-x或--one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。-X&lt;文件&gt;或--exclude-from&#x3D;&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。--exclude&#x3D;&lt;目录或文件&gt; 略过指定的目录或文件。--max-depth&#x3D;&lt;目录层数&gt; 超过指定层数的目录后，予以忽略。--help 显示帮助。--version 显示版本信息","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zuoyoulai.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zuoyoulai.github.io/tags/Linux/"}],"author":{"nick":"samlai","link":"https://github.com/ZuoYouLai"}},{"title":"优秀 GitHub 资源","slug":"Good-GitHub","date":"2020-01-08T09:52:20.000Z","updated":"2020-01-09T06:13:54.576Z","comments":true,"path":"2020/01/08/Good-GitHub/","link":"","permalink":"https://zuoyoulai.github.io/2020/01/08/Good-GitHub/","excerpt":"","text":"优秀 GitHub 资源 Java 相关 Linux 相关 Go 相关 ## 优秀 GitHub 资源 Java 相关 名称 Url 架构师知识 https://doocs.github.io/advanced-java/ 大数据笔记 https://github.com/heibaiying/BigData-Notes?utm_source=gold_browser_extension 分布式任务调度 xxl-job https://github.com/xuxueli/xxl-job?utm_source=gold_browser_extension Linux 相关 名称 Url Go 相关 名称 Url go学习系列文章 https://www.liwenzhou.com/categories/Golang/","categories":[{"name":"GitHub","slug":"GitHub","permalink":"https://zuoyoulai.github.io/categories/GitHub/"}],"tags":[{"name":"学习文章","slug":"学习文章","permalink":"https://zuoyoulai.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/"},{"name":"GitHub","slug":"GitHub","permalink":"https://zuoyoulai.github.io/tags/GitHub/"}],"author":{"nick":"samlai","link":"https://github.com/ZuoYouLai"}},{"title":"Go语言之 BeeGo 学习","slug":"Go-BeeGo","date":"2020-01-07T15:07:43.000Z","updated":"2020-01-25T14:27:26.417Z","comments":true,"path":"2020/01/07/Go-BeeGo/","link":"","permalink":"https://zuoyoulai.github.io/2020/01/07/Go-BeeGo/","excerpt":"","text":"Go语言之 BeeGo 学习 Gopm 安装操作 Gopm 安装操作 go get -v github.com/gpmgo/gopm 没有反应,需要修改 12345678910Mac 修改 host:&gt;&gt; sudo vi &#x2F;etc&#x2F;hosts添加内容:192.30.253.112 github.com151.101.185.194 github.global.ssl.fastly.netwq 退出 下载完之后可以执行 gopm get 来替代 go get 的操作: 12345678910111213141516171819202122232425gopm get -g -v github.com&#x2F;astaxie&#x2F;beegogo get -v github.com&#x2F;astaxie&#x2F;beegogopm get -g -v github.com&#x2F;beego&#x2F;beegopm get -g -v golang.org&#x2F;x&#x2F;netgo get -v golang.org&#x2F;x&#x2F;netgo get github.com&#x2F;beego&#x2F;beego get -v github.com&#x2F;beego&#x2F;beego get -u -v github.com&#x2F;kataras&#x2F;irisgo get -u -v github.com&#x2F;gin-gonic&#x2F;gingopm get -v github.com&#x2F;kataras&#x2F;irisgo get -v github.com&#x2F;hyper-carrot&#x2F;go_lib&#x2F;logginggo get -v github.com&#x2F;astaxie&#x2F;beegogo get -v golang.org&#x2F;x&#x2F;net 发现以上的方式，访问 github.com 还是很慢，所以得修改成另外一种方式:123git clone https:&#x2F;&#x2F;www.github.com&#x2F;hunterhug&#x2F;rabbitmkdir -p %GOPATH%&#x2F;src&#x2F;github.com&#x2F;hunterhugmv rabbit %GOPATH%&#x2F;src&#x2F;github.com&#x2F;hunterhug 修改 host 文件的内容，提高访问 github.com 的项目123456789101112131415161718192021Mac 修改 host:&gt;&gt; sudo vi &#x2F;etc&#x2F;hosts添加内容:#github192.30.253.112 github.com192.30.253.120 codeload.github.com219.76.4.4 github-cloud.s3.amazonaws.com151.101.185.194 github.global.ssl.fastly.net151.101.24.133 assets-cdn.github.com151.101.196.133 avatars0.githubusercontent.com151.101.196.133 avatars1.githubusercontent.com103.245.222.133 assets-cdn.github.com204.232.175.78 documentcloud.github.com204.232.175.94 gist.github.com107.21.116.220 help.github.com207.97.227.252 nodeload.github.com199.27.76.130 raw.github.com107.22.3.110 status.github.com204.232.175.78 training.github.com","categories":[{"name":"Go","slug":"Go","permalink":"https://zuoyoulai.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://zuoyoulai.github.io/tags/Go/"},{"name":"BeeGo","slug":"BeeGo","permalink":"https://zuoyoulai.github.io/tags/BeeGo/"}],"author":{"nick":"samlai","link":"https://github.com/ZuoYouLai"}},{"title":"Linux 用户权限权限管理","slug":"Linux-authority","date":"2020-01-02T08:29:54.000Z","updated":"2020-01-02T15:47:40.596Z","comments":true,"path":"2020/01/02/Linux-authority/","link":"","permalink":"https://zuoyoulai.github.io/2020/01/02/Linux-authority/","excerpt":"","text":"Linux 用户权限权限管理 创建新用户 用户对文件夹,文件操作权限 例子 : 赋予所有者后删除文件则权限不够 例子 : 无秘登录 samlai 的普通账号 创建新用户 以 root 用户为创建的基础 12345678910111213141516171819201.创建新的用户,名称为:samlai&gt;&gt; useradd samlai2.添加 samlai 密码:&gt;&gt; passwd samlai&gt;&gt; 更改用户 samlai 的密码 。 新的 密码： 重新输入新的 密码： passwd：所有的身份验证令牌已经成功更新 laihaoda123&gt;&gt;3.切换到 samlai 用户:&gt;&gt; su samlai4.切换到 root 再进行修改 samlai 的密码&gt;&gt; su&gt;&gt; passwd samlai 用户对文件夹,文件操作权限 权限的说明: 12345678910111213-rw-rw-r-- 1 root root 22 1月 2 22:41 one.sh首字母类型:- : 文件d : 文件夹l : 链接后面9位字母代表: r:4 w:2 x:1-rw(所属用户：root 权限)-rw(所属组: root 权限)r--(其他用户的权限) 修改权限操作: 12chmod u+x one.txt 对所属用户添加权限chmod g+w,o+w one.txt 对所属组，其他用户添加写的权限 权限对文件的作用 123456r : cat more head tailw : vi echo [注意:不包括删除文件]x : 可执行 [对文件来说可执行是最高的权限] 权限对目录的左右 123456r : lsw : touch rm mv cp [这里文件夹的写权限就可以针对于文件删除的操作]x : 可以进入目录 cd[对文件来说写操作是最高的权限] 修改文件的所有者: 12chown laihaoda one.txt 修改文件的所属组: 12 chgrp samlai one.txt 查看默认权限命令 12umask 例子 : 赋予所有者后删除文件则权限不够1234567891011121314151617181920212223242526&gt;&gt; su &gt;&gt; ll总用量 4.0K-rwxrwxr-x 2 root root 4.0K 1月 2 22:41 one.sh&gt;&gt; chown samlai .&#x2F;one.sh&gt;&gt; ll总用量 4.0K-rw-rw-r-- 1 samlai root 22 1月 2 22:41 one.sh&gt;&gt; su samlai&gt;&gt; rm -rf one.shrm: 无法删除&quot;one.sh&quot;: 权限不够[即使是所属者都无法删除权限，问题就是在于 : 文件所在的文件夹并不属于 samlai 根本原因: 文件夹与文件在分区的时候，是分开来,文件夹则管理着文件夹与其对应的文件名称,个数等之类。但所属者仅仅有对文件全部全部行为，除了删除。]&gt;&gt; su 把对应的文件夹所属者改成 samlai&gt;&gt; chown samlai ..&#x2F;one&gt;&gt; ll总用量 4.0Kdrwxrwxr-x 2 samlai root 4.0K 1月 2 22:41 one&gt;&gt; su samlai&gt;&gt; rm -rf one.sh这样就可以成功的删除了 例子 : 无秘登录 samlai 的普通账号 参考链接 : https://blog.csdn.net/lizhiyuan_eagle/article/details/80494512 1234567891011121314151617181920212223242526272829303132A机器无密登录 B 机器的操作: ssh root@ipAddress2台机器 A 本地 B 远程:In A机器：1.yum install ssh2.ssh-keygen -t rsa -C &quot;472023527@qq.com&quot;3.cat ~&#x2F;.ssh&#x2F;id_rsa.pub &#x2F;&#x2F; id_rsa是私钥将这个公钥给机器 B 中In B机器命令:# touch &#x2F;home&#x2F;samlai&#x2F;.ssh&#x2F;authorized_keys (如果已经存在这个文件, 跳过这条)[新的用户: 没有 .ssh 目录 则需要创建]&gt;&gt; mkdir ~&#x2F;.ssh# cat &#x2F;home&#x2F;samlai&#x2F;.ssh&#x2F;id_rsa.pub &gt;&gt; &#x2F;home&#x2F;samlai&#x2F;.ssh&#x2F;authorized_keys (将id_rsa.pub的内容追加到authorized_keys 中)samalai&#x2F;.ssh和authorized_keys的权限#chmod 700 samlai#chmod 700 .ssh#chmod 600 authorized_keys回到A机器:# ssh samlai@192.168.60.110 (不需要密码, 登录成功)测试成功！！！","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zuoyoulai.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zuoyoulai.github.io/tags/Linux/"}],"author":{"nick":"samlai","link":"https://github.com/ZuoYouLai"}},{"title":"Go 指针,数组,切片,Map","slug":"Go-Struct1","date":"2020-01-02T02:25:02.000Z","updated":"2020-01-02T02:36:57.846Z","comments":true,"path":"2020/01/02/Go-Struct1/","link":"","permalink":"https://zuoyoulai.github.io/2020/01/02/Go-Struct1/","excerpt":"","text":"Go 指针,数组,切片,Map 指针 数组 切片: slice Map Go 引用的方式只有一种 : 值传递 指针 Go语言的指针是不能进行运算的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport \"fmt\"/**Go 指针:1.值,引用传递: 值: 值进行拷贝 引入: 地址的引用2.Go 引用的方式只有一种 : 值传递*/func main() &#123; a,b :=1, 100 swap(&amp;a, &amp;b) fmt.Printf(\"指针打印的 swap : a = %d b = %d\\n\",a,b) d,c :=9, 88 d,c =swapK(d, c) fmt.Printf(\"返回多个值 swap : d = %d c = %d\\n\",d,c) /** 打印: 指针打印的 swap : a = 100 b = 1 返回多个值 swap : d = 9 c = 88 */&#125;/** 指针操作的2数互换 */func swap(a,b *int)&#123; *a,*b=*b,*a&#125;func swapK(a,b int) (int, int) &#123; return b, a&#125; 数组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package mainimport \"fmt\"/**数组： 1. 定义数组 2. 遍历数组 3. range 遍历 4. 数组是值类型: 值拷贝 在数组进行轮询的时候对某些角标值修改值的时候,因为数组是类型,是值拷贝,不会影响数组原来的值 如果需要引用的话,可以加指针操作 5. go语言一般不使用数组,是切片 */func main() &#123; //定义 var arr1 [5]int arr2 := [3]int&#123;1, 2, 3&#125; arr3 := [...]int&#123;10, 21, 33, 49, 54&#125; var grid [4][5]int PrintArr(arr1) PrintArr(arr3) //打印内容 fmt.Println(arr1,\" \",arr2,\" \", arr3,\" \", grid) //使用 range 打印 index value for i,v:=range arr3 &#123; fmt.Println(i, v) &#125; fmt.Println(\"\\n\") //如果只需要值的可以这样遍历 for _,v:=range arr3 &#123; fmt.Println(v) &#125; /** 打印结果: 100 0 0 0 0 100 21 33 49 54 [0 0 0 0 0] [1 2 3] [10 21 33 49 54] [[0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0]] 0 10 1 21 2 33 3 49 4 54 10 21 33 49 54 */&#125;func PrintArr(arr [5]int) &#123; for i:=range arr &#123; //数组是值传递 即使修改了值也改变不了原来的数组内容 if i == 0 &#123; arr[i]= 100 &#125; fmt.Println(arr[i]) &#125; fmt.Println(\"\\n\")&#125; 切片: slice simpleSliceTest.go 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package mainimport \"fmt\"/**Go 语言很重要部分: Slice 1. slice 扩展 2. 向slice添加元素 */func main() &#123; arr := [...]int&#123;2, 23, 392, 22, 9, 4&#125; //半开半闭区间操作: //arr[2:5] --&gt; arr[2] ... arr[4] //故结果: [392 22 9] fmt.Println(arr[2:5]) s1:=arr[2:] fmt.Println(s1) updateArr(s1) fmt.Println(s1) s2:=arr[:] fmt.Println(s2) /** 打印: [392 22 9] [392 22 9 4] [99 22 9 4] [2 23 99 22 9 4] */ //slice 扩展 var sa = []int&#123;0, 1, 2, 3, 4, 5, 6, 7,&#125; fmt.Println(sa) ss1:=sa[2:6] ss2:=ss1[3:5] fmt.Println(\"ss1 : \",ss1) fmt.Println(\"ss2 : \",ss2) /** [0 1 2 3 4 5 6 7] ss1 : [2 3 4 5] ss2 : [5 6] slice 可以向后扩展 不可以向前扩展 s[i] 不可以超越len(s),向后扩展不可以超越底层数组 cap(s) */ //打印相应的 caps fmt.Printf(\"ss1 = %v, len(ss1) = %d , cap(ss1) = %d \\n\",ss1,len(ss1),cap(ss1)) fmt.Printf(\"ss2 = %v, len(ss2) = %d , cap(ss2) = %d \\n\",ss2,len(ss2),cap(ss2)) /** ss1 = [2 3 4 5], len(ss1) = 4 , cap(ss1) = 6 ss2 = [5 6], len(ss2) = 2 , cap(ss2) = 3 */&#125;func updateArr(arr []int) &#123; arr[0]= 99&#125; doSlice.go 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package mainimport \"fmt\"/**操作 slice: 1. append 添加元素 2. copy slice 3. delete one element from slice 4. remove from head and tail */func main() &#123; var arr []int PrintSlice(arr) //arr = [], len(arr) = 0 , cap(arr) = 0 fmt.Println(\"append element\") arr =append(arr, 10,20, 30) PrintSlice(arr) // arr = [10 20 30], len(arr) = 3 , cap(arr) = 4 //手动的创建 slice arr1 :=make([]int, 16) PrintSlice(arr1) //arr = [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], len(arr) = 16 , cap(arr) = 16 arr2 :=make([]int,16, 25) PrintSlice(arr2) //arr = [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], len(arr) = 16 , cap(arr) = 25 fmt.Println(\"copy slice\") copy(arr1, arr) PrintSlice(arr1) //arr = [10 20 30 0 0 0 0 0 0 0 0 0 0 0 0 0], len(arr) = 16 , cap(arr) = 16 fmt.Println(\"delete one element from slice\") //删掉上面的30元素,index =2 arr1=append(arr1[:2],arr1[3:]...) PrintSlice(arr1) //arr = [10 20 0 0 0 0 0 0 0 0 0 0 0 0 0], len(arr) = 15 , cap(arr) = 16 fmt.Println(\"remove from head and tail\") arr1=arr1[1:] PrintSlice(arr1) //arr = [20 0 0 0 0 0 0 0 0 0 0 0 0 0], len(arr) = 14 , cap(arr) = 15 arr1=arr1[:len(arr1)-1] PrintSlice(arr1) //arr = [20 0 0 0 0 0 0 0 0 0 0 0 0], len(arr) = 13 , cap(arr) = 15&#125;func PrintSlice(arr []int) &#123; fmt.Printf(\"arr = %v, len(arr) = %d , cap(arr) = %d \\n\",arr,len(arr),cap(arr))&#125; Map DoGoMap.go 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package mainimport \"fmt\"/**Map : 1.创建方式: 这个是 HashMap 类型 m:=map[string]string&#123;&#125; m:=make(map[string]int) 2.获取元素 3.判断元素是否存在 if 4.删除某个元素 5.range 遍历 6.key 类型: 除了 slice map function 内建类型都可以作为 key struct类型不包含上述字段，也可以作为 key*/func main() &#123; //创建 map m:=map[string]string&#123;&#125; //添加元素 m[\"lai\"]= \"Lai\" m[\"hao\"]= \"Hao\" m[\"da\"]= \"Da\" PrintMap(m) /** lai Lai hao Hao da Da */ //删除元素 delete(m, \"lai\") PrintMap(m) /** hao Hao da Da */ //修改元素 m[\"hao\"]= \"HAhahaha..\" PrintMap(m) /** hao HAhahaha.. da Da */ //判断元素是否存在 key,ok:=m[\"da\"] fmt.Println(key, ok) // Da true if key,ok:=m[\"da\"]; ok &#123; fmt.Println(\"存在此 key \",key) &#125; else &#123; fmt.Printf(\"don't have key %s exist\", key) &#125; //存在此 key Da&#125;func PrintMap(m map[string]string) &#123; for k,v :=range m &#123; fmt.Println(k,v) &#125; fmt.Println(\"\")&#125;","categories":[{"name":"Go","slug":"Go","permalink":"https://zuoyoulai.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://zuoyoulai.github.io/tags/Go/"}],"author":{"nick":"samlai","link":"https://github.com/ZuoYouLai"}},{"title":"每天学习一个 Linux 指令 1  scp","slug":"Linux-scp","date":"2020-01-01T02:55:57.000Z","updated":"2020-01-01T05:04:29.917Z","comments":true,"path":"2020/01/01/Linux-scp/","link":"","permalink":"https://zuoyoulai.github.io/2020/01/01/Linux-scp/","excerpt":"","text":"每天学习一个 Linux 指令 1 : scp 说明 命令格式 12scp [参数] [源路径] [目标路径] 命令参数 实例 复制文件 复制目录 123scp -r local_folder remote_username@remote_ip:remote_folder : 指定了用户名，命令执行后需要输入用户密码 scp -r local_folder remote_ip:remote_folder : 没有指定用户名，命令执行后需要输入用户名和密码 从远程服务器复制到本地服务器 12从远程复制到本地的scp命令与上面的命令雷同，只要将从本地复制到远程的命令后面2个参数互换顺序就行了。 例子 1 : 从远处复制文件到本地目录 1234scp root@192.168.120.204:&#x2F;opt&#x2F;soft&#x2F;nginx-0.5.38.tar.gz &#x2F;opt&#x2F;soft&#x2F;从192.168.120.204机器上的&#x2F;opt&#x2F;soft&#x2F;的目录中下载nginx-0.5.38.tar.gz 文件到本地&#x2F;opt&#x2F;soft&#x2F;目录中 例子 2 : 从远处复制到本地 例子 3 : 上传本地文件到远程机器指定目录 例子 4 : 上传本地目录到远程机器指定目录 例子 5 : 从远处目录到本地指定目录 + ssh key 123456789101112131415161718192021222324A机器无密登录 B 机器的操作: ssh root@ipAddress2台机器 A 本地 B 远程:In A机器：1.yum install ssh2.ssh-keygen -t rsa -C &quot;472023527@qq.com&quot;3.cat ~&#x2F;.ssh&#x2F;id_rsa.pub &#x2F;&#x2F; id_rsa是私钥将这个公钥给机器 B 中In B机器:进入&#x2F;root&#x2F;.ssh&#x2F;目录中 将 A 机器的公钥给复制到 B 器文件 : sam.pub然后执行指令:&gt;&gt; cat sam.pub &gt;&gt; &#x2F;root&#x2F;.ssh&#x2F;authorized_keys (将id_rsa.pub的内容追加到authorized_keys 中)接下来就可以执行 scp 的操作了:scp -r root@192.168.120.204:&#x2F;opt&#x2F;soft&#x2F;mongodb &#x2F;opt&#x2F;soft&#x2F; 参考文章 说明12345678scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来。另外，scp还非常不占资源，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。虽然 rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I&#x2F;O非常高，而scp基本不影响系统正常使用。scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。linux的scp命令可以在linux服务器之间复制文件和目录。 命令格式 格式: 12scp [参数] [源路径] [目标路径] 命令参数 参数:1234567891011121314151617181920212223242526272829303132333435363738scp [参数] [源路径] [目标路径]这里的参数:-1 强制scp命令使用协议ssh1 -2 强制scp命令使用协议ssh2 -4 强制scp命令只使用IPv4寻址 -6 强制scp命令只使用IPv6寻址 -B 使用批处理模式（传输过程中不询问传输口令或短语） -C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能） -p 保留原文件的修改时间，访问时间和访问权限。 -q 不显示传输进度条。 -r 递归复制整个目录。 -v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。 -c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。 -F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。 -i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。 -l limit 限定用户所能使用的带宽，以Kbit&#x2F;s为单位。 -o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式， -P port 注意是大写的P, port是指定数据传输用到的端口号 -S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。 实例复制文件12345678910命令执行后需要输入用户密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名:1. scp local_file remote_username@remote_ip:remote_folder2. scp local_file remote_username@remote_ip:remote_file第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名3. scp local_file remote_ip:remote_folder 4. scp local_file remote_ip:remote_file 复制目录123scp -r local_folder remote_username@remote_ip:remote_folder : 指定了用户名，命令执行后需要输入用户密码 scp -r local_folder remote_ip:remote_folder : 没有指定用户名，命令执行后需要输入用户名和密码 从远程服务器复制到本地服务器12从远程复制到本地的scp命令与上面的命令雷同，只要将从本地复制到远程的命令后面2个参数互换顺序就行了。 例子 1 : 从远处复制文件到本地目录1234scp root@192.168.120.204:&#x2F;opt&#x2F;soft&#x2F;nginx-0.5.38.tar.gz &#x2F;opt&#x2F;soft&#x2F;从192.168.120.204机器上的&#x2F;opt&#x2F;soft&#x2F;的目录中下载nginx-0.5.38.tar.gz 文件到本地&#x2F;opt&#x2F;soft&#x2F;目录中 例子 2 : 从远处复制到本地1234scp -r root@192.168.120.204:&#x2F;opt&#x2F;soft&#x2F;mongodb &#x2F;opt&#x2F;soft&#x2F;从192.168.120.204机器上的&#x2F;opt&#x2F;soft&#x2F;中下载mongodb 目录到本地的&#x2F;opt&#x2F;soft&#x2F;目录来。 例子 3 : 上传本地文件到远程机器指定目录1234scp &#x2F;opt&#x2F;soft&#x2F;nginx-0.5.38.tar.gz root@192.168.120.204:&#x2F;opt&#x2F;soft&#x2F;scptest复制本地opt&#x2F;soft&#x2F;目录下的文件nginx-0.5.38.tar.gz 到远程机器192.168.120.204的opt&#x2F;soft&#x2F;scptest目录 例子 4 : 上传本地目录到远程机器指定目录1234scp -r &#x2F;opt&#x2F;soft&#x2F;mongodb root@192.168.120.204:&#x2F;opt&#x2F;soft&#x2F;scptes上传本地目录 &#x2F;opt&#x2F;soft&#x2F;mongodb到远程机器192.168.120.204上&#x2F;opt&#x2F;soft&#x2F;scptest的目录中去 例子 5 : 从远处目录到本地指定目录 + ssh key123456789101112131415161718192021222324A机器无密登录 B 机器的操作: ssh root@ipAddress2台机器 A 本地 B 远程:In A机器：1.yum install ssh2.ssh-keygen -t rsa -C &quot;472023527@qq.com&quot;3.cat ~&#x2F;.ssh&#x2F;id_rsa.pub &#x2F;&#x2F; id_rsa是私钥将这个公钥给机器 B 中In B机器:进入&#x2F;root&#x2F;.ssh&#x2F;目录中 将 A 机器的公钥给复制到 B 器文件 : sam.pub然后执行指令:&gt;&gt; cat sam.pub &gt;&gt; &#x2F;root&#x2F;.ssh&#x2F;authorized_keys (将id_rsa.pub的内容追加到authorized_keys 中)接下来就可以执行 scp 的操作了:scp -r root@192.168.120.204:&#x2F;opt&#x2F;soft&#x2F;mongodb &#x2F;opt&#x2F;soft&#x2F; 参考文章 来自 : https://www.cnblogs.com/peida/archive/2013/03/15/2960802.html ssh无秘登录的操作 : https://blog.csdn.net/lizhiyuan_eagle/article/details/80494512","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zuoyoulai.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zuoyoulai.github.io/tags/Linux/"}],"author":{"nick":"samlai","link":"https://github.com/ZuoYouLai"}},{"title":"Git使用内容","slug":"Git-md","date":"2019-12-31T09:17:19.000Z","updated":"2019-12-31T09:55:29.769Z","comments":true,"path":"2019/12/31/Git-md/","link":"","permalink":"https://zuoyoulai.github.io/2019/12/31/Git-md/","excerpt":"","text":"Git 使用 添加用户基本信息 删掉本地 Or 远程分支 本地生成 key 写入 GitHub 中 sshkey 方便提交代码 cherry-pick : 只更新某个 commit 的里面内容 回滚到之前某个分支 强行覆盖的最新的内容 备份项目 : 项目同时推送到githhub与coding 添加用户基本信息 可以让本地提交的内容有相应的用户,这样就看 git log 的时候则会出现什么用户提交过了,而不是某个邮箱地址内容提交 123git config --global user.name &quot;xxxx@qq.com&quot;git config --global user.email &quot;xxx@qq.com&quot; 删掉本地 Or 远程分支1234删除分支：git branch -d &lt;name&gt;删除远程分支：git push origin --delete &lt;name&gt; 本地生成 key 写入 GitHub 中 sshkey 方便提交代码 github添加一个ssh key 1234567891011121314Linux:1.yum install ssh2.ssh-keygen -t rsa -C &quot;472023527@qq.com&quot;3.cat ~&#x2F;.ssh&#x2F;id_rsa.pub [复制粘贴到github头像那边的setting再进行添加相应的key值]4.以后进行git操作的代码的时候则不是git https:&#x2F;&#x2F;xxx的方式Windows:1. 安装git，桌面右键点击 &quot;Git Bash&quot;2. cd ~&#x2F;.ssh&#x2F; 3. vi id_rsa.pub 如有 复制内容，在github.com的网站上到ssh密钥管理页面，添加新公钥4. 如没有自行创建公钥 cherry-pick : 只更新某个 commit 的里面内容1234567891011121314151617181920212223将A分支的一个commit合并到B分支： 首先切换到A分支 git checkout A git log 找出要合并的commit ID : 例如 xxx001 然后切换到B分支上 git checkout B git cherry-pick xxx001 然后就将A分支的某个commit合并到了B分支了 回滚到之前某个分支12345678910111213查找对应Log的 id:git log -3 回滚到指定的版本:git reset --hard e377f60e28c8b84158git reset --hard 156d981 强制提交:git push -f origin master 强行覆盖的最新的内容1234567891011121314151617将一个分支覆盖相应的分支: 1.切换到test分支上 git checkout test 2.将master合并到test git merge master 3.将master分支删掉 git branch -d master 4.将test分支覆盖到master分支上 git branch -m test master 5.将master分支推送远程库上[有分支则覆盖 无分支则创建新的分支并更新上去] git push -f origin master 备份项目 : 项目同时推送到githhub与coding 在 CODING 中新建一个同名项目，不选择 启用 README.md 文件初始化项目，以及任何 License 和 .gitignore 文件 在本地项目上添加一个: 123456789101112131415161718 git remote set-url --add origin https:&#x2F;&#x2F;git.coding.net&#x2F;samlai&#x2F;xxx.git ps:项目的根目录.git文件夹下confi配置文件变成[remote &quot;origin&quot;]url &#x3D; https:&#x2F;&#x2F;github.com&#x2F;ZuoYouLai&#x2F;xxx.gitfetch &#x3D; +refs&#x2F;heads&#x2F;*:refs&#x2F;remotes&#x2F;origin&#x2F;*url &#x3D; https:&#x2F;&#x2F;git.coding.net&#x2F;samlai&#x2F;xxx.git[branch &quot;master&quot;]remote &#x3D; originmerge &#x3D; refs&#x2F;heads&#x2F;master指令辅助： (git remote 看看现在项目git 远程主机情况) git remote -v (git remote add 添加一个远程主机) git remote add xx xxx.git (git remote rm xx 删掉远程某个远程的配置内容) 修改本地项目的任意一个文件: 1234git add . git commit -m &#39;test&#39;git push origin master &#x2F;&#x2F; 把本地仓库的变化连接到远程仓库主分支 参考文章: https://feitianbenyue.iteye.com/blog/2376791 https://coding.net/help/doc/git/import.html","categories":[{"name":"Git","slug":"Git","permalink":"https://zuoyoulai.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://zuoyoulai.github.io/tags/Git/"}],"author":{"nick":"samlai","link":"https://github.com/ZuoYouLai"}},{"title":"Go 学习","slug":"Go-Study","date":"2019-12-29T07:20:44.000Z","updated":"2020-01-07T15:11:08.053Z","comments":true,"path":"2019/12/29/Go-Study/","link":"","permalink":"https://zuoyoulai.github.io/2019/12/29/Go-Study/","excerpt":"","text":"GO 语言学习 学习 安装 指令操作 Import 操作： 变量代码 常量 特殊常量 iota 使用 编程 例子1 : Http:HelloWorld 例子2 : 多线程 + 线程间通信 例子3 : 数组的内部排序 例子4 : 单元测试操作 例子5 : 基准测试 学习 指令 : go tool tour 文档 : http://docscn.studygolang.com/doc/ 安装 Linux 1234567891011121314151617181920212223242526272829下载 &gt; 解压 &gt; 设置下载: wget https:&#x2F;&#x2F;dl.google.com&#x2F;go&#x2F;go1.13.5.linux-amd64.tar.gz 解压: tar -C &#x2F;usr&#x2F;local&#x2F; -xzf go1.13.5.linux-amd64.tar.gz &gt; cd &#x2F;usr&#x2F;local&#x2F;go &gt; bin&#x2F;go version &gt; go version go1.13.5 linux&#x2F;amd64 设置: &gt;&gt; vim &#x2F;etc&#x2F;profile &gt;&gt; 添加到最后如下指令 #go path GOROOT&#x3D;&#x2F;usr&#x2F;local&#x2F;go export PATH&#x3D;$PATH:$GOROOT&#x2F;bin &gt;&gt; 退出 wq ，执行: source % &gt;&gt; go env &#x2F;&#x2F;可以正常打印内容 说明安装成功 GOROOTGOPATH Mac系统下GOBINPATH Mac 设置 GoPath : https://www.jianshu.com/p/5c1873eaf3ca 12345678910111213141516171819202122232425262728293031323334 编辑~&#x2F;.bash_profile文件: export GOROOT&#x3D;&#x2F;usr&#x2F;local&#x2F;go export GOPATH&#x3D;&#x2F;Users&#x2F;haodalai&#x2F;Desktop&#x2F;Go&#x2F;project export GOBIN&#x3D; export PATH&#x3D;$PATH:$&#123;GOPATH&#x2F;&#x2F;:&#x2F;&#x2F;bin:&#125;&#x2F;bin 退出执行:source ~&#x2F;.bash_profile Or编辑~&#x2F;.zshrc文件export GOROOT&#x3D;&#x2F;usr&#x2F;local&#x2F;goexport GOPATH&#x3D;&#x2F;Users&#x2F;haodalai&#x2F;Desktop&#x2F;Go&#x2F;projectexport GOBIN&#x3D;export PATH&#x3D;$PATH:$&#123;GOPATH&#x2F;&#x2F;:&#x2F;&#x2F;bin:&#125;&#x2F;bin退出执行:source ~&#x2F;.zshrc最终执行:&gt;&gt; echo $GOPATH 【注意: 以后开发的项目都放在$GOPATH 的 src 目录下】 MacWindows指令操作12345678910111213141516171819202122go run -v 列出被编译的代码包名称 -a 强制执行 -work 显示临时工作目录并不删除它 -x 打印命令 并执行过它的 -n 打印编译的命令但不执行他们 -p n: 并行编译 其中 n 为并行的数量 go build 编译源码文件或代码包 go install 编译并安装代码或者源码文件查看执行文件:ls $GOBIN go get 从远程代码仓库上下载安装代码包下载到$GOPATH下 第一个文件的的 src文件夹中 -d 只执行下载动作不执行安装动作 -fix 下载后先执行修正动作 再进行编译安装 -U 利用网络来更新已有的代码包及其依赖包 Import 操作： 如果一个 main 导入其他包，包将被顺序导入 如果导入的包依赖其他包(包 B)，会首先导入 B 包，然后初始化 B 包中常量和变量，最后如果 B 包中有 init，会自动执行 init() 如果包导入完成后对 main 中常量和变量进行初始化，执行 main 中的 init函数 如果一个包被导入多次则该包只会被导入一次 import 别名 “.” “_”1234别名：将导入的包命名为另一个容易记忆的别名点操作: .标识的包导入后，调用该包中函数时可以省略前缀包名下划线(_)操作: 导入该包，但不导入整个包，而是执行包中的 init 函数此无法通过包名来调用包中的其他函数 使用下划线操作往往为了注册包中的引擎，让外部可以方便地使用 变量代码 全局变量需要加上 var 方法体内则可以不用加上 大写字母开头可以被包内其他文件导入，小写则不行 常量 类型：显示 隐式1234显式：const identifier [type] &#x3D; value隐式：const identifier &#x3D; value (通常叫无类型常量)常量可以使用内置表达式定义 ： 例如 len() unsafe.Sizeof()常量范围目前只支持布尔，数字，字符串 特殊常量 iota 使用 iota在 const 关键字出现时将被重置为0 const 中每新增一行常量声明将使 iota 计数一次 iota 常见用法12341. 跳值使用法2. 插队使用法3. 表达式隐式使用法4. 单行使用法 编程例子1 : Http:HelloWorld12345678910111213141516package mainimport ( \"fmt\" \"net/http\")func main() &#123; http.HandleFunc(\"/\", func(writer http.ResponseWriter, request *http.Request) &#123; fmt.Fprint(writer,\"Hello World! Mr.Sam赖\") &#125;) http.ListenAndServe(\":8989\",nil)&#125;访问： http://localhost:8989 例子2 : 多线程 + 线程间通信12345678910111213141516171819202122232425package mainimport \"fmt\"func main() &#123; ch :=make(chan string) for i:=0; i&lt;10;i++ &#123; go hello(i, ch) &#125; for &#123; msg :=&lt;-ch fmt.Print(msg) &#125; &#125;func hello(i int,ch chan string) &#123; for &#123; ch &lt;- fmt.Sprintf(\"Hello World...%d \\n \", i) &#125;&#125; 例子3 : 数组的内部排序123456789101112131415package mainimport ( \"fmt\" \"sort\")func main() &#123; //排序 arr:=[]int&#123;45, 23, 6, 12, 1, 905, 16, 75&#125; sort.Ints(arr) for _,val:=range arr &#123; fmt.Println(val) &#125;&#125; 例子4 : 单元测试操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package mainimport \"testing\"/** 1.文件名称必须以: _test 作为后缀 2.忽略测试 t.SkipNow() 3.执行指令: go test -v 4.注意点: 方法名称一定需要 : Test_xxxx 名称 Test 为首字母大写 方法体参数内容 : t *testing.T 5.日志显示: t.Log() t.Error() */func TestRepeat(t *testing.T) &#123; a :=repeat(\"a\") t.Log(\"a 的值\"+ a) k := \"aaaaa\" if a == k &#123; t.Logf(\"测试成功,a 的值为 : %s\",a) &#125;&#125;func TestPk(t *testing.T) &#123; t.Log( t.Name(),\"开始执行 Pt 的内容\") for i:=0;i&lt; 9 ;i++ &#123; repeat(\"a\") &#125;&#125;func repeat(s string) string&#123; var result string for i:=0; i&lt;5 ;i++ &#123; result+= \"a\" &#125; return result&#125;func TestAdd(t *testing.T) &#123; //忽略测试 //t.SkipNow() t.Log(t.Name(), \"Begin....\") a := 2 b := 3 if add(a,b) != 5&#123; t.Errorf(\"result %d \",add(a, b)) &#125; t.Logf(\"a + b is : %d\",add(a,b)) t.Log(t.Name(), \"end....\")&#125;func add(a,b int) int &#123; return a + b&#125;/** go test -v 打印结果：=== RUN TestRepeat--- PASS: TestRepeat (0.00s) lx_test.go:18: a 的值aaaaa lx_test.go:21: 测试成功,a 的值为 : aaaaa=== RUN TestPk--- PASS: TestPk (0.00s) lx_test.go:27: TestPk 开始执行 Pt 的内容=== RUN TestAdd--- PASS: TestAdd (0.00s) lx_test.go:45: TestAdd Begin.... lx_test.go:51: a + b is : 5 lx_test.go:52: TestAdd end....PASS */ 例子5 : 基准测试 参考链接 ： http://c.biancheng.net/view/124.html1234567891011121314151617181920212223242526272829303132/** 参考链接 : http://c.biancheng.net/view/124.html 基准测试: 1.一定需要方法名称 : Benchmark开头 2.执行的指令: go test -v -bench=. go test -v -bench=. jz_test.go 增加自定义时间: go test -v -bench=. -benchtime=5s jz_test.go */func BenchmarkAdd(b *testing.B) &#123; var n int for i:=0;i&lt;b.N;i++ &#123; n++ &#125;&#125;/**执行: go test -v -bench=.打印的内容:goos: darwingoarch: amd64BenchmarkAdd-16 1000000000 0.238 ns/opPASS测试说明：执行了: 1000000000 次每次的操作时间: 0.238 ns*/","categories":[{"name":"Go","slug":"Go","permalink":"https://zuoyoulai.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://zuoyoulai.github.io/tags/Go/"}],"author":{"nick":"samlai","link":"https://github.com/ZuoYouLai"}},{"title":"Linux-Vim 插件,指令的学习","slug":"Linux-Vim","date":"2019-12-26T16:20:02.000Z","updated":"2020-01-01T04:44:58.450Z","comments":true,"path":"2019/12/27/Linux-Vim/","link":"","permalink":"https://zuoyoulai.github.io/2019/12/27/Linux-Vim/","excerpt":"","text":"Vim 编辑器学习 zsh 安装 系统间无密登录 VIM 快捷键 查找 VIm 插件方式 VIm 安装插件 Vim 编辑器学习 学习地址 ： https://www.cnblogs.com/vijozsoft/p/5608108.html vimrc : https://www.cnblogs.com/yuandonghua/p/10483882.html zsh 安装 安装指令: 1sh -c &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;robbyrussell&#x2F;oh-my-zsh&#x2F;master&#x2F;tools&#x2F;install.sh)&quot; 修改主题: https://github.com/ohmyzsh/ohmyzsh/wiki/themes 12345&gt;&gt; vim ~&#x2F;.zshrc主题我喜欢修改成: af-magicZSH_THEME&#x3D;&quot;af-magic&quot;生效:&gt;&gt; exec $SHELL bash和zsh切换 123456切换到bashchsh -s &#x2F;bin&#x2F;bash切换到zshchsh -s &#x2F;bin&#x2F;zsh 卸载oh my zsh : Mac 参考链接 : https://my.oschina.net/u/2391658/blog/1584566 1在命令行输入如下命令，回车即可：uninstall_oh_my_zsh 系统间无密登录123456789101112131415161718A机器无密登录 B 机器的操作: ssh root@ipAddress2台机器 A 本地 B 远程:In A机器：1.yum install ssh2.ssh-keygen -t rsa -C &quot;472023527@qq.com&quot;3.cat ~&#x2F;.ssh&#x2F;id_rsa.pub &#x2F;&#x2F; id_rsa是私钥将这个公钥给机器 B 中In B机器:进入&#x2F;root&#x2F;.ssh&#x2F;目录中 将 A 机器的公钥给复制到 B 器文件 : sam.pub然后执行指令:&gt;&gt; cat sam.pub &gt;&gt; &#x2F;root&#x2F;.ssh&#x2F;authorized_keys (将id_rsa.pub的内容追加到authorized_keys 中) VIM 快捷键基本使用 [ shift + : ] : 进入 normal 模式 [ i ] : 插入编写操作 –&gt; insert操作 [ a ] : append在光标处添加模式 [ wq ] : 书写+退出操作 [ q ] :退出 [ !q ] :强制退出操作 [ esc 或者 control + [ ] : 插入模式转为 normal模式 光标移动 Ctrl + u 【往前翻页】 Ctrl + f 【往前翻页 : forward】 gg : 第一行 GG : 最后一行 0 : 行首 $ : 行尾 V : 选中行内容 使用 k j 来选中内容 h : 向左 j ：向下 k : 向上 l : 向右 0 : 回到行首 $ : 回到行尾 gg : 回到行首 G : 回到行尾 u : 返回上一步 control + r : 重复上一步的操作 插入字符 i a I : 回到行头进行插入 A: 进入光标所对应的行尾插入 p : 粘贴 yy ：复制一行 删除字符 x : 向后删除单个字符 X : 向前删除单个字符 nx，nX : 删除多个字符的操作 打开文件 vim 1.txt 2.txt -O 查找 VIm 插件方式 google 的方式 浏览: vimawesome.com : https://vimawesome.com/ VIm 安装插件插件工具 : vim-plugin 插件工具内容：vim-plugin : https://github.com/junegunn/vim-plug12345678910mac 系统执行:curl -fLo ~&#x2F;.vim&#x2F;autoload&#x2F;plug.vim --create-dirs \\ https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;junegunn&#x2F;vim-plug&#x2F;master&#x2F;plug.vim编写添加内容到 vimrc:call plug#begin(&#39;~&#x2F;.vim&#x2F;plugged&#39;)call plug#end() 浏览最近插件: vim-startify 安装浏览最近的文件的插件: vim-startify : https://github.com/mhinz/vim-startify123456789101112131415Plug &#39;mhinz&#x2F;vim-startify&#39;编写添加内容到 vimrc:&gt;&gt; vim ~&#x2F;.vimrccall plug#begin(&#39;~&#x2F;.vim&#x2F;plugged&#39;)Plug &#39;mhinz&#x2F;vim-startify&#39;call plug#end()然后让 vimrc 进行生效：进入 vim ~&#x2F;.vimrc 的 normal 模式 执行2个指令：:source ~&#x2F;.vimrc:PluginInstall插件就可以成功安装：然后执行 vim 就可以查看就近打开的文件内容 代码补全的插件：vim-surround 代码补全的插件：surround : https://github.com/tpope/vim-surround1234567891011Plug &#39;tpope&#x2F;vim-surround&#39;使用方式:ds (delete a surrounding)cs (change a surrounding)ys (you add a surrounding)光标在单词的左处:ds iw &#39; --&gt; 将字符添加一个单引号cs &#39; &quot; --&gt; 将字符的单引号变成双引号ds &quot; --&gt; 删除&quot;引号 状态栏美化: vim-airline 状态栏美化: vim-airline : https://github.com/vim-airline/vim-airline 12Plug &#39;vim-airline&#x2F;vim-airline&#39;Plug &#39;vim-airline&#x2F;vim-airline-themes&#39; 代码缩进线条:indentline 代码缩进线条:indentline 1Plug &#39;yggdroot&#x2F;indentline&#39; 配色: vim-hybrid 配色: vim-hybrid: https://github.com/w0ng/vim-hybrid12345678Plug &#39;w0ng&#x2F;vim-hybrid&#39;其他配置加上vimrc:set background&#x3D;darkcolorscheme hybrid 【本地安装了：Oh My Zsh 】 需要修改相应的主题：https:&#x2F;&#x2F;github.com&#x2F;ohmyzsh&#x2F;ohmyzsh&#x2F;wiki&#x2F;themesvim ~&#x2F;.zshrcZSH_THEME&#x3D;&quot;af-magic&quot; 树形文件目录 : nerdtree 树形文件夹管理:12345678910111213141516171819202122232425262728293031323334 Plug &#39;scrooloose&#x2F;nerdtree&#39; 添加 Ctrl+n 方式:(vimrc) map &lt;C-n&gt; :NERDTreeToggle&lt;CR&gt; 配合使用 Normal 方式操作： Ctrl+n 打开树结构 :vs 打开新的窗体 ctrl+w+w 光标在左右窗口切换 快捷键： 参考链接内容: https:&#x2F;&#x2F;blog.csdn.net&#x2F;Lius_1006&#x2F;article&#x2F;details&#x2F;79524512 h j k l移动光标定位 ctrl+w+w 光标在左右窗口切换 ctrl+w+r 切换当前窗口左右布局 ctrl+p 模糊搜索文件 gT 切换到前一个tab g t 切换到后一个tab o 打开关闭文件或者目录，如果是文件的话，光标出现在打开的文件中 O 打开结点下的所有目录 X 合拢当前结点的所有目录 x 合拢当前结点的父目录 i和s水平分割或纵向分割窗口打开文件 u 打开上层目录t 在标签页中打开 T 在后台标签页中打开 p 到上层目录 P 到根目录 K 到同目录第一个节点 J 到同目录最后一个节点 m 显示文件系统菜单（添加、删除、移动操作） ? 帮助 :q 关闭 快速定位文件:ctrlp 快速定位文件:ctrlp : https://github.com/kien/ctrlp.vim 1234Plug &#39;kien&#x2F;ctrlp.vim&#39;添加快捷键：let g:ctrlp_map &#x3D; &#39;&lt;c-p&gt;&#39; 快速查找文件字符 ：easymotion 快速查找文件字符 ：easymotion https://github.com/easymotion/vim-easymotion 1234567Plug &#39;easymotion&#x2F;vim-easymotion&#39;添加快捷键：nmap ss &lt;Plug&gt;(easymotion-s2)可能安装的插件的时间比较长 需要等下使用的方式:按下 ss 键 写入单个字符 就可以全文查找 根据某个特定的字符来跳到相应的位置上 模糊搜索：fzf 模糊搜索 : https://github.com/junegunn/fzf.vim 123456Plug &#39;junegunn&#x2F;fzf&#39;, &#123; &#39;dir&#39;: &#39;~&#x2F;.fzf&#39;, &#39;do&#39;: &#39;.&#x2F;install --all&#39; &#125;Plug &#39;junegunn&#x2F;fzf.vim&#39;常用指令::Files [PATH] 查找文件名称的搜索:Ag [PATTERN] 查找文件字符的搜索 全局替换: far 全局替换: https://github.com/brooth/far.vim 1234Plug &#39;brooth&#x2F;far.vim&#39;:Far foo bar **&#x2F;*.py:Fardo go 语言代码的书写: vim-go github : https://github.com/fatih/vim-go 说明文档 : https://github.com/fatih/vim-go-tutorial 123Plug &#39;fatih&#x2F;vim-go&#39;, &#123; &#39;do&#39;: &#39;:GoUpdateBinaries&#39; &#125;指令使用: 注释内容插件：vim-commentary 注释内容: https://github.com/tpope/vim-commentary 123456Plug &#39;tpope&#x2F;vim-commentary&#39;使用 gc 进行注释选择多行进行注释操作::V j k (向上向下选取内容) + gc 就可以进行多行注释(任何语言都是可以进行注释的)","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zuoyoulai.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zuoyoulai.github.io/tags/Linux/"},{"name":"Vim","slug":"Vim","permalink":"https://zuoyoulai.github.io/tags/Vim/"}],"author":{"nick":"samlai","link":"https://github.com/ZuoYouLai"}},{"title":"docker笔记内容","slug":"docker笔记内容","date":"2019-12-25T07:25:03.000Z","updated":"2019-12-29T16:40:03.219Z","comments":true,"path":"2019/12/25/docker笔记内容/","link":"","permalink":"https://zuoyoulai.github.io/2019/12/25/docker%E7%AC%94%E8%AE%B0%E5%86%85%E5%AE%B9/","excerpt":"","text":"Docker 学习笔记内容 docker-swarm: Docker 学习笔记内容 jdk 与 docker各种版本之间限制:【很好的博文 来自】 12345678简言之：注意资源限制的不匹配。测试你的内存设置和JVM标志，不要假设任何东西。如果您在Docker容器中运行Java，请确保你设置了docker内存限制和在JVM中也做了限制，或者你的JVM能够理解这些限制。如果您无法升级您的Java版本，请使用-Xmx设置您自己的限制。对于Java 8和Java 9，请更新到最新版本并使用： -XX：+UnlockExperimentalVMOptions -XX：+UseCGroupMemoryLimitForHeapdocker run -m 100m -it adoptopenjdk&#x2F;openjdk10:nightly &#x2F;bin&#x2F;bash对于Java 10，确保它支持’UseContainerSupport’（更新到最新版本）。docker run -m 100m -it adoptopenjdk&#x2F;openjdk9-openj9 &#x2F;bin&#x2F;bash对于OpenJ9（我强烈建议使用，可以在生产环境中有效减少内存占用量），现在使用-Xmx设置限制，但很快会出现一个支持UseContainerSupport标志的版本。 1.配置的docker容器,外网不可以访问，只能内网才可以进行访问 12docker run xxx -p 3306:3306 -d xximage : 这个port会对外网可以进行访问,无视防火墙的设置docker run xxx -p 127.0.0.1:3306:3306 -d xximage : 这个port是针对本地的地址的内容，外网无法进行访问 2.清空的none的docker镜像内容 1docker rmi $(docker images -f &quot;dangling&#x3D;true&quot; -q) 3.docker可视化工具:portainer 参考资料 | 官方文档 1234567891011121314151617181920212223242526272829303132333435 1.拉取镜像：docker pull portainer&#x2F;portainer 2.docker run相应的脚本内容： local本地模式开启: 添加 ： -v &quot;&#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock&quot; docker run -d -p 9000:9000 \\ --restart&#x3D;always \\ -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock \\ --name prtainer-test \\ docker.io&#x2F;portainer&#x2F;portainer 3.访问相应的ip地址：http:&#x2F;&#x2F;IP:9000 &#96;&#96;&#96; - 4.docker无法查看jvm的参数 [参考资料](https:&#x2F;&#x2F;blog.csdn.net&#x2F;kinginblue&#x2F;article&#x2F;details&#x2F;78078028)&#96;&#96;&#96;text 1.使用 --cap-add 明确添加指定功能： docker run --cap-add&#x3D;SYS_PTRACE ... 2.docker compose添加的相应指令: version: &#39;2&#39; services: mysql: ... api: ... cap_add: - SYS_PTRACE &#96;&#96;&#96; - 5.docker对jdk资源的限制: [参考资料](https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000014142950)- 6.docker compose指令 : [参考资料](https:&#x2F;&#x2F;www.cnblogs.com&#x2F;52fhy&#x2F;p&#x2F;5991344.html) - 7.docker容器启动非常的缓慢 死机 [参考](https:&#x2F;&#x2F;my.oschina.net&#x2F;u&#x2F;1188877&#x2F;blog&#x2F;422405?p&#x3D;1)&#96;&#96;&#96;text 1.sudo service docker stop 2.rm -rf &#x2F;var&#x2F;lib&#x2F;docker&#x2F;* #(记得备份重要数据) 3.sudo servie docker start 8.linux报错:kernel:unregister_netdevice: waiting for lo to become free. Usage count = 1 docker-compose12docker-compose up 执行docker镜像的内容docker-compose build 会执行文件里面需要build的镜像内容,然后再进行up的处理 docker-swarm:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374751.生产环境的使用，多机器，扩展部署2.Node有2种角色：Manager Worker3.Manager要多节点部署避免单点故障 需要共享库来同步状态4.Service 和 Replicas5.Manager进行做决策多部署服务到多个节点上 6.docker swarm 指令: A.docker swarm --advertise-addr&#x3D;[IP] 初始化manager 查看join的信息然后把内容加入到子节点上 B.docker node ls 查看manager节点信息 看到manger+worker的节点信息7.swarm环境搭建好之后，进行对service进行操作 A.创建服务: docker service create -name [Images] bash B.docker service ls C.docker service ps demo D.docker service scale&#x3D;[Num] 水平扩展到不一样的机器8.docker swarm部署 wordpress A.创建网络：共享的网络 docker network create -d overlay demo B.docker service create xxxName C.多节点的同步问题：overlay : 原理是DNS服务来发现的功能，为连overlay建一条日志 docker swarm技术: Routing Mesh的两种体现：【题外话：Lvs+keepalived实现高可用集群】 A. Internal : container 和 container之间的访问通过overlay网络(通过Vip虚拟Ip) 【具体原理可以查看 [图片](&#x2F;images&#x2F;Internal原理.png)】 B. Ingress ： 如果服务有绑定接口，则此服务可以通过任意swarm节点的相应接口访问 作用: 外部访问的负载均衡 服务端口被暴露到各个swarm节点 内部通过IpVs进行负载均衡 [Ingress流程图 ： &#x2F;images&#x2F;Ingress.png] [数据包传输流程图 ： &#x2F;images&#x2F;Ingress数据包走向.png] 9.docker发布服务在生产环境: 借助compose 的 version &#x3D; 3部署到生产环境上 docker stack deploy 执行的compose文件的内容 docker stack remove 进行删掉的services服务 10.DOckerSecret管理 Secret Management: 1.存在Swarm Manager节点Raft database里 2.Secret可以assign给一个service,这个service就能看到这个secret 3.在container内部secret看起来像文件，但是实际上在内存中 指令: 创建: docker secret create my-pwd 删除: docker secret rm my-pwd 在创建一个secret在一个容器中，容器里面的文件夹中有相应的内容： 1. docker service create --name xxx --secret my-pwd 【imagesName】 2. docker service ls 查看服务节点多少个 3. docker service ps [name] 查看服务节点在哪里 4. cat &#x2F;run&#x2F;secrests&#x2F;my-pwd 就可以查看secret的明文内容 11.Swarm更新服务(生产环境): A.运行一个service docker service create --name web --publish 8080:5000 --network demo flask:1.0 B.运行2个节点的操作 docker service scale web&#x3D;2 3.运行shell指令来测试 sh -c &quot;while true; do curl 127.0.0.1:8080&amp;&amp;sleep 1;done&quot; 4.更新指令很多内容: docker service update --help 5.更新images的版本 docker service update --image flask:2.0 web 6.更新端口的操作:删掉原来的端口并添加新的端口操作 docker service ps web docker service update --publish-rm 8080:5000 --publish-add 8099:5000 web 12. dockerEE 企业版:可以查看swarm部署多个节点监控状态 在dockerEE基础上部署DTR,其作用是扫描镜像的安全性问题 阿里云也有相应的docker-swarm服务，但是相应的付费还是蛮昂贵的 替代Docker Compose实现容器双向联通的三种方法","categories":[{"name":"Docker","slug":"Docker","permalink":"https://zuoyoulai.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://zuoyoulai.github.io/tags/Docker/"}],"author":{"nick":"samlai","link":"https://github.com/ZuoYouLai"}},{"title":"windows-Mq 启动操作","slug":"windows-Mq","date":"2019-12-25T06:08:48.000Z","updated":"2019-12-29T16:40:03.227Z","comments":true,"path":"2019/12/25/windows-Mq/","link":"","permalink":"https://zuoyoulai.github.io/2019/12/25/windows-Mq/","excerpt":"","text":"Windows RocketMq Console管理控制台的启动 启动的脚本 访问 Windows RocketMq Console管理控制台的启动下载 &amp; 打包123git clone https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;rocketmq-externals.gitcd rocketmq-externals&#x2F;rocketmq-console&#x2F;mvn clean package -Dmaven.test.skip&#x3D;true 启动的脚本 3.5版本以下 1java -jar target\\rocketmq-console-ng-1.0.1.jar --rocketmq.config.namesrvAddr&#x3D;127.0.0.1:9876 &gt; log.txt --rocketmq.config.isVIPChannel&#x3D;false 3.5版本以下 1java -jar target\\rocketmq-console-ng-1.0.1.jar --rocketmq.config.namesrvAddr&#x3D;127.0.0.1:9876 &gt; log.txt 还有其他的配置可以自定义配置的：【以下配置来自console项目的 application.properties】 1234567891011121314151617181920212223242526272829server.contextPath&#x3D;server.port&#x3D;8080### SSL setting#server.ssl.key-store&#x3D;classpath:rmqcngkeystore.jks#server.ssl.key-store-password&#x3D;rocketmq#server.ssl.keyStoreType&#x3D;PKCS12#server.ssl.keyAlias&#x3D;rmqcngkey#spring.application.index&#x3D;truespring.application.name&#x3D;rocketmq-consolespring.http.encoding.charset&#x3D;UTF-8spring.http.encoding.enabled&#x3D;truespring.http.encoding.force&#x3D;truelogging.config&#x3D;classpath:logback.xml#if this value is empty,use env value rocketmq.config.namesrvAddr NAMESRV_ADDR | now, you can set it in ops page.default localhost:9876rocketmq.config.namesrvAddr&#x3D;#if you use rocketmq version &lt; 3.5.8, rocketmq.config.isVIPChannel should be false.default truerocketmq.config.isVIPChannel&#x3D;#rocketmq-console&#39;s data path:dashboard&#x2F;monitorrocketmq.config.dataPath&#x3D;&#x2F;tmp&#x2F;rocketmq-console&#x2F;data#set it false if you don&#39;t want use dashboard.default truerocketmq.config.enableDashBoardCollect&#x3D;true#set the message track trace topic if you don&#39;t want use the default onerocketmq.config.msgTrackTopicName&#x3D;rocketmq.config.ticketKey&#x3D;ticket#Must create userInfo file: $&#123;rocketmq.config.dataPath&#125;&#x2F;users.properties if the login is requiredrocketmq.config.loginRequired&#x3D;false 如果出错的话则查看log.txt文件内容 访问访问URL : http://localhost:8080/ 正确启动","categories":[{"name":"Mq","slug":"Mq","permalink":"https://zuoyoulai.github.io/categories/Mq/"},{"name":"Rocketmq","slug":"Mq/Rocketmq","permalink":"https://zuoyoulai.github.io/categories/Mq/Rocketmq/"}],"tags":[{"name":"Rocketmq","slug":"Rocketmq","permalink":"https://zuoyoulai.github.io/tags/Rocketmq/"}],"author":{"nick":"samlai","link":"https://github.com/ZuoYouLai"}},{"title":"借鉴博客学习","slug":"借鉴博客学习-md","date":"2019-12-25T02:27:44.000Z","updated":"2020-01-08T06:28:16.159Z","comments":true,"path":"2019/12/25/借鉴博客学习-md/","link":"","permalink":"https://zuoyoulai.github.io/2019/12/25/%E5%80%9F%E9%89%B4%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0-md/","excerpt":"优秀文章内容 文档 博客内容 优秀文章内容 权威文档 优秀笔记内容 个人博客","text":"优秀文章内容 文档 博客内容 优秀文章内容 权威文档 优秀笔记内容 个人博客 文档 名称 Url go学习系列文章 https://www.liwenzhou.com/categories/Golang/ 互联网扫盲笔记 https://doocs.github.io/advanced-java/#/ 下载资源网盘 https://m.pantianxia.com/ 下载资源 http://www.xiazaij.com/author/xiazaij/ zlnnjit(博客一直在持续的更新) https://www.bcoder.top/ jboot https://jboot.io/ 鸟哥私房菜 http://cn.linux.vbird.org/linux_basic/linux_basic.php k8s http://kubernetes.kansea.com/docs/hellonode/ 唯品会开发手册 https://vipshop.github.io/vjtools/#/standard/ leecode编程算法网站 https://leetcode-cn.com/problemset/all/ 许雪里开源列表 http://www.xuxueli.com/page/projects.html 代码有毒的笔记 https://zq99299.github.io/note-book/ ES权威指南笔记 http://blog.didispace.com/books/elasticsearch-definitive-guide-cn/ Cyc2018笔记脑图 http://naotu.baidu.com/file/b49ccc722da46972dfe3a720cd414a11 Java虚拟机：JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解 https://www.fangzhipeng.com/javainterview/2019/04/17/jvm-tools.html Shiro用starter方式优雅整合到SpringBoot中 比较全面的 https://segmentfault.com/a/1190000014479154?utm_source=index-hottest rocketMq的笔记内容 https://www.bcoder.top/2017/12/17/%E4%B8%9A%E4%BD%99%E5%AD%A6%E4%B9%A0%E4%B9%8BRocketMQ%E4%B8%AD%E7%BA%A7%E7%AF%87/#%E6%B6%88%E8%B4%B9%E8%80%85%E6%B6%88%E6%81%AF%E9%87%8D%E8%AF%95 容器面试笔记 http://www.spring4all.com/article/6786 阿飞的博客 https://www.jianshu.com/u/6779ec81d3b7 正则表达式学习 http://blog.didispace.com/regular-expression-all/ 【课程】Elastic Stack入门与实践 https://www.imooc.com/article/45855 【课程】Elastic Stack入门与实践 [描述的较好] https://blog.csdn.net/hiwes/article/category/8448094 【课程】JVM笔记内容 http://www.imooc.com/article/details/id/251567#param-type jdk各个版本间docker兼容问题 https://kelvinji2009.github.io/tags/docker/ k8s开启 https://kelvinji2009.github.io/blog/kubernetes-bible-beginners/ 【课程】Nginx入门到实践 https://www.jianshu.com/nb/32398790 【极客时间】从0开始学架构【笔记】 https://zhimap.com/mhtml/6159a37f642c480e984e9ad5d97e2489 IO流读取的比较 https://www.cnkirito.moe/file-io-best-practise/ 使用Redis的分布式锁 https://wudashan.cn/2017/10/23/Redis-Distributed-Lock-Implement/ ##特指权威性的网站名称 | Url——|—–elasticsearch日报 | https://elasticsearch.cn/docker中文文档 | https://docs.docker-cn.comdocker中文论坛社区 | http://dockone.io/jenkins官方的文档内容 | https://jenkins.io/zh/sharding-jdbc官方中文文档 | https://shardingsphere.apache.org/document/current/cn/overview/docker-file 良好的实践 | https://juejin.im/entry/5d2405be6fb9a07f091bc7f3?utm_source=gold_browser_extension 博客内容 名称 Url ASM获取参数 https://www.cnblogs.com/relucent/p/6525821.html 书籍的推荐 https://blog.csdn.net/u011896537/article/details/89467774 mrbird[很多java的干货] https://mrbird.cc/ [小窝小窝] https://z77z.oschina.io/ 死磕java[文章非常的全面系统] http://cmsblogs.com/?page_id=3027 猿天地 http://cxytiandi.com/article 周立博客[springboot + springcloud教程 书作者] http://www.itmuch.com/ 程序员DDD [springboot + springcloud教程 书作者] http://blog.didispace.com/ 方志朋[spring cloud教程] https://www.cnblogs.com/forezp/category/1327932.html 方志朋[spring cloud + java + 架构] https://www.fangzhipeng.com 纯洁的微笑[springboot + springcloud教程] http://www.ityouknow.com/ java知音[java基础 面试 web 各种java基础 算法] https://www.javazhiyin.com 匠心零度[jvm rocketmq] http://www.jiangxinlingdu.com/ anoyi[k8s docker-swarm 还有书籍的下载] https://anoyi.com Loull[蛮坚持写博客的人 实用性还是蛮高的] https://www.cnblogs.com/549294286/ 叶落[Nginx NIO资料不是很多] http://www.liqinghe.com/technology.html 技术栈蛮深,涉略spring redis boot https://www.cnblogs.com/hujunzheng 不折腾会死 (shiro 文章可能较少) https://segmentfault.com/blog/die4zhe [阿里数据库内核主管] http://hedengcheng.com/?p=771 [core java] http://www.carlzone.cn [数据结构] http://timd.cn [架构分布式] http://www.kailing.pub [一个未毕业却很努力却很强技术栈学生] https://www.cnblogs.com/yueshutong/ [java 高级知识点：rocketmq 分布式事务 分布式锁] https://www.jianshu.com/u/bbe9e62bc5ba spring4all http://www.spring4all.com/ Hollis https://www.hollischuang.com/ 梁桂钊 http://blog.720ui.com/columns/springboot_all/ 码小猪 https://www.hchstudio.cn 若鱼 https://blog.csdn.net/goldenfish1919 许雪里 http://www.xuxueli.com/blog/#/?id=%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80 py教师+容器化视频的讲师 http://www.imooc.com/t/5634820 代码有毒 https://blog.csdn.net/mr_zhuqiang 屈定 https://mrdear.cn/ 吾爱程序员 https://www.52programer.com/ 代码有毒的笔记博客 https://zq99299.github.io/note-book/ 代码有毒的CSDN https://blog.csdn.net/mr_zhuqiang kelvinji2009[很牛的人] https://kelvinji2009.github.io/ 运维的笔记 http://www.zsythink.net/ 技术颜良[文章很有水准] https://www.cnblogs.com/cheyunhua/p/?page=32 Java知识分享[下载pdf文章] http://www.java1234.com/ 芋道源码[各种java源码解析] http://www.iocoder.cn/ 空挡 网络 rocketmq https://www.jianshu.com/u/d00590abcb80 [es springboot flink] http://www.54tianzhisheng.cn 架构研究 http://www.shinians.com/html/blog.html 人工智能 https://www.captainbed.net/mengday/ Hexo博客安装 https://y0ngb1n.github.io/","categories":[{"name":"学习文章","slug":"学习文章","permalink":"https://zuoyoulai.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"学习文章","slug":"学习文章","permalink":"https://zuoyoulai.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/"},{"name":"GitHub","slug":"GitHub","permalink":"https://zuoyoulai.github.io/tags/GitHub/"}],"author":{"nick":"samlai","link":"https://github.com/ZuoYouLai"}},{"title":"我的 Hexo 博客系统的搭建","slug":"hexo-study-md","date":"2019-12-24T15:50:00.000Z","updated":"2019-12-29T16:40:03.229Z","comments":true,"path":"2019/12/24/hexo-study-md/","link":"","permalink":"https://zuoyoulai.github.io/2019/12/24/hexo-study-md/","excerpt":"","text":"搭建个人博客站点 Mac 环境系统搭建博客 Linux 环境系统搭建博客 git 发布的插件 添加 hexo 文章目录插件 ### 搭建个人博客站点 + 本地 Linux 需要安装 : Git + 本地 Mac 安装 node ：https://nodejs.org/en/download/ Mac 环境系统搭建博客 mac 安装 node 权限的问题,解决问题链接：https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally 1234567891011121314151617181920212223242526会出现 root 与 本地用户操作权限的问题，如：npm install -g xxx 操作的需要做出如下操作:&gt;&gt; mkdir ~&#x2F;.npm-global&gt;&gt; npm config set prefix &#39;~&#x2F;.npm-global&#39;&gt;&gt; vim ~&#x2F;.bash_profile添加如下：export PATH&#x3D;&#x2F;Users&#x2F;haodalai&#x2F;.npm-global&#x2F;bin:$PATHexport PATH&#x3D;&#x2F;Users&#x2F;haodalai&#x2F;Blog&#x2F;node_modules&#x2F;.bin:$PATH&gt;&gt; echo $PATH&gt;&gt; source ~&#x2F;.bash_profile &gt;&gt; npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org （测试是 ok 的）mac 安装 hexo：路径设置：&gt;&gt; export PATH&#x3D;~&#x2F;Blog&#x2F;node_modules&#x2F;.bin:$PATH&gt;&gt; echo $PATH&gt;&gt; hexo （测试生效）新建一个hexo 项目&gt;&gt; mkdir ~&#x2F;Blog&#x2F;Samlai-Blog&gt;&gt; hexo init ~&#x2F;Blog&#x2F;Samlai-Blog&gt;&gt; Linux 环境系统搭建博客 Linux 参考 Hexo 文档来进行搭建博客站点： https://hexo.io/zh-cn/docs/12345678910111213141516171819202122232425261. 安装 nodejs 使用这种方式来安装 : Linux（DEB&#x2F;RPM-based）：从 NodeSource 安装 参考链接 ： https:&#x2F;&#x2F;github.com&#x2F;nodesource&#x2F;distributions 因为本地是 centos 执行指令 : &gt;&gt; curl -sL https:&#x2F;&#x2F;rpm.nodesource.com&#x2F;setup_12.x | bash - 执行完成后: &gt;&gt; sudo yum install -y nodejs 2. 使用淘宝镜像 cnpm : &gt;&gt; npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org 3. 使用 npm 安装 hexo: &gt;&gt; cnpm install hexo 4. 将 Hexo 所在的目录下的 node_modules 添加到环境变量之中即可直接使用 hexo &lt;command&gt;： &gt;&gt; echo &#39;PATH&#x3D;&quot;$PATH:&#x2F;opt&#x2F;hexo&#x2F;node_modules&#x2F;.bin&quot;&#39; &gt;&gt; ~&#x2F;.profile 注意: 我安装hexo 目录到我的系统路径为 : &#x2F;opt&#x2F;hexo 执行上面没有效果的话，无法识别 hexo 指令的话，则可以直接修改 ： vim &#x2F;etc&#x2F;profile 文件 文件最后面写上: HEXO_HOME&#x3D;&#x2F;opt&#x2F;hexo&#x2F;node_modules&#x2F;.bin PATH&#x3D;$PATH:$HEXO_HOME 使用 HEXO 创建项目123456789101112131. 初始化 hexo 项目hexo init &#x2F;opt&#x2F;blog2. 生成静态文件hexo generate3.运行服务器hexo server4.创建文件内容hexo new post 借鉴博客学习.md 修改 hexo 的主题与发布12345678910111213141516171819202122232425262728293031323334353637381. 注册一个 githhub 账号 并建一个名称为： xxx(你的 github 账号).github.io 项目2. 在服务新建一个github ssh key: 1.yum install ssh 2.ssh-keygen -t rsa -C &quot;472023527@qq.com&quot; 3.cat ~&#x2F;.ssh&#x2F;id_rsa.pub [复制粘贴到github头像那边的setting再进行添加相应的key值] 4.以后进行git操作的代码的时候则不是git https:&#x2F;&#x2F;xxx的方式 5.创建全局的 git 账号: [hexo d 执行的时候会报错] git config --global user.email &quot;472023527@qq.com&quot; git config --global user.name &quot;samlai&quot; 3. 拉取主题内容: cd &#x2F;opt&#x2F;blog git clone https:&#x2F;&#x2F;github.com&#x2F;litten&#x2F;hexo-theme-yilia.git themes&#x2F;yilia 4. 修改 hexo 的发布的方式： vim _config.yml 修改发布方式: deploy: type: git repository: git@github.com:ZuoYouLai&#x2F;ZuoYouLai.github.io.git branch: master 修改主题内容： themes: yilia 5. 安装 hexo 的 git 插件 : cnpm install hexo-deployer-git --save 6. 执行 hexo 发布执行操作： hexo d (hexo deploy) hexo s (hexo server) hexo 与 github.io 共同的发布操作12345github.io 的文件都是为：本地执行 hexo d 指令编译成静态文件然后并上传到 github.io 的仓库中.所以可以访问 https:&#x2F;&#x2F;zuoyoulai.github.io&#x2F; 可以直接访问静态文件 html 内容项目的保存最好存 md 文件的 github 的仓库的，每次写完自己新的笔记 md 文件后，提交github 仓库为了备份 md 文件内容。保存好 md 文件后再在本地执行：hexo -d 【编译好静态文件并上传到 github.io 的仓库上】 git 发布的插件1cnpm install hexo-deployer-git --save 添加 hexo 文章目录插件1234cnpm install hexo-toc --save在文章标题下添加：&lt;!-- toc --&gt; 本文参考 https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html https://www.jianshu.com/p/1bcad7700c46","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zuoyoulai.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://zuoyoulai.github.io/tags/Hexo/"}],"author":{"nick":"samlai","link":"https://github.com/ZuoYouLai"}}]}