{"meta":{"title":"左之右","subtitle":"SamLai'Blog","description":"A Java Programmer,Never To Late...","author":{"name":"samlai","link":"https://github.com/ZuoYouLai"},"url":"https://zuoyoulai.github.io","root":"/"},"pages":[],"posts":[{"title":"Linux 用户权限权限管理","slug":"Linux-authority","date":"2020-01-02T08:29:54.000Z","updated":"2020-01-02T15:47:40.596Z","comments":true,"path":"2020/01/02/Linux-authority/","link":"","permalink":"https://zuoyoulai.github.io/2020/01/02/Linux-authority/","excerpt":"","text":"Linux 用户权限权限管理 创建新用户 用户对文件夹,文件操作权限 例子 : 赋予所有者后删除文件则权限不够 例子 : 无秘登录 samlai 的普通账号 创建新用户 以 root 用户为创建的基础 12345678910111213141516171819201.创建新的用户,名称为:samlai&gt;&gt; useradd samlai2.添加 samlai 密码:&gt;&gt; passwd samlai&gt;&gt; 更改用户 samlai 的密码 。 新的 密码： 重新输入新的 密码： passwd：所有的身份验证令牌已经成功更新 laihaoda123&gt;&gt;3.切换到 samlai 用户:&gt;&gt; su samlai4.切换到 root 再进行修改 samlai 的密码&gt;&gt; su&gt;&gt; passwd samlai 用户对文件夹,文件操作权限 权限的说明: 12345678910111213-rw-rw-r-- 1 root root 22 1月 2 22:41 one.sh首字母类型:- : 文件d : 文件夹l : 链接后面9位字母代表: r:4 w:2 x:1-rw(所属用户：root 权限)-rw(所属组: root 权限)r--(其他用户的权限) 修改权限操作: 12chmod u+x one.txt 对所属用户添加权限chmod g+w,o+w one.txt 对所属组，其他用户添加写的权限 权限对文件的作用 123456r : cat more head tailw : vi echo [注意:不包括删除文件]x : 可执行 [对文件来说可执行是最高的权限] 权限对目录的左右 123456r : lsw : touch rm mv cp [这里文件夹的写权限就可以针对于文件删除的操作]x : 可以进入目录 cd[对文件来说写操作是最高的权限] 修改文件的所有者: 12chown laihaoda one.txt 修改文件的所属组: 12 chgrp samlai one.txt 查看默认权限命令 12umask 例子 : 赋予所有者后删除文件则权限不够1234567891011121314151617181920212223242526&gt;&gt; su &gt;&gt; ll总用量 4.0K-rwxrwxr-x 2 root root 4.0K 1月 2 22:41 one.sh&gt;&gt; chown samlai .&#x2F;one.sh&gt;&gt; ll总用量 4.0K-rw-rw-r-- 1 samlai root 22 1月 2 22:41 one.sh&gt;&gt; su samlai&gt;&gt; rm -rf one.shrm: 无法删除&quot;one.sh&quot;: 权限不够[即使是所属者都无法删除权限，问题就是在于 : 文件所在的文件夹并不属于 samlai 根本原因: 文件夹与文件在分区的时候，是分开来,文件夹则管理着文件夹与其对应的文件名称,个数等之类。但所属者仅仅有对文件全部全部行为，除了删除。]&gt;&gt; su 把对应的文件夹所属者改成 samlai&gt;&gt; chown samlai ..&#x2F;one&gt;&gt; ll总用量 4.0Kdrwxrwxr-x 2 samlai root 4.0K 1月 2 22:41 one&gt;&gt; su samlai&gt;&gt; rm -rf one.sh这样就可以成功的删除了 例子 : 无秘登录 samlai 的普通账号 参考链接 : https://blog.csdn.net/lizhiyuan_eagle/article/details/80494512 1234567891011121314151617181920212223242526272829303132A机器无密登录 B 机器的操作: ssh root@ipAddress2台机器 A 本地 B 远程:In A机器：1.yum install ssh2.ssh-keygen -t rsa -C &quot;472023527@qq.com&quot;3.cat ~&#x2F;.ssh&#x2F;id_rsa.pub &#x2F;&#x2F; id_rsa是私钥将这个公钥给机器 B 中In B机器命令:# touch &#x2F;home&#x2F;samlai&#x2F;.ssh&#x2F;authorized_keys (如果已经存在这个文件, 跳过这条)[新的用户: 没有 .ssh 目录 则需要创建]&gt;&gt; mkdir ~&#x2F;.ssh# cat &#x2F;home&#x2F;samlai&#x2F;.ssh&#x2F;id_rsa.pub &gt;&gt; &#x2F;home&#x2F;samlai&#x2F;.ssh&#x2F;authorized_keys (将id_rsa.pub的内容追加到authorized_keys 中)samalai&#x2F;.ssh和authorized_keys的权限#chmod 700 samlai#chmod 700 .ssh#chmod 600 authorized_keys回到A机器:# ssh samlai@192.168.60.110 (不需要密码, 登录成功)测试成功！！！","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zuoyoulai.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zuoyoulai.github.io/tags/Linux/"}],"author":{"nick":"samlai","link":"https://github.com/ZuoYouLai"}},{"title":"Go 指针,数组,切片,Map","slug":"Go-Struct1","date":"2020-01-02T02:25:02.000Z","updated":"2020-01-02T02:36:57.846Z","comments":true,"path":"2020/01/02/Go-Struct1/","link":"","permalink":"https://zuoyoulai.github.io/2020/01/02/Go-Struct1/","excerpt":"","text":"Go 指针,数组,切片,Map 指针 数组 切片: slice Map Go 引用的方式只有一种 : 值传递 指针 Go语言的指针是不能进行运算的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport \"fmt\"/**Go 指针:1.值,引用传递: 值: 值进行拷贝 引入: 地址的引用2.Go 引用的方式只有一种 : 值传递*/func main() &#123; a,b :=1, 100 swap(&amp;a, &amp;b) fmt.Printf(\"指针打印的 swap : a = %d b = %d\\n\",a,b) d,c :=9, 88 d,c =swapK(d, c) fmt.Printf(\"返回多个值 swap : d = %d c = %d\\n\",d,c) /** 打印: 指针打印的 swap : a = 100 b = 1 返回多个值 swap : d = 9 c = 88 */&#125;/** 指针操作的2数互换 */func swap(a,b *int)&#123; *a,*b=*b,*a&#125;func swapK(a,b int) (int, int) &#123; return b, a&#125; 数组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package mainimport \"fmt\"/**数组： 1. 定义数组 2. 遍历数组 3. range 遍历 4. 数组是值类型: 值拷贝 在数组进行轮询的时候对某些角标值修改值的时候,因为数组是类型,是值拷贝,不会影响数组原来的值 如果需要引用的话,可以加指针操作 5. go语言一般不使用数组,是切片 */func main() &#123; //定义 var arr1 [5]int arr2 := [3]int&#123;1, 2, 3&#125; arr3 := [...]int&#123;10, 21, 33, 49, 54&#125; var grid [4][5]int PrintArr(arr1) PrintArr(arr3) //打印内容 fmt.Println(arr1,\" \",arr2,\" \", arr3,\" \", grid) //使用 range 打印 index value for i,v:=range arr3 &#123; fmt.Println(i, v) &#125; fmt.Println(\"\\n\") //如果只需要值的可以这样遍历 for _,v:=range arr3 &#123; fmt.Println(v) &#125; /** 打印结果: 100 0 0 0 0 100 21 33 49 54 [0 0 0 0 0] [1 2 3] [10 21 33 49 54] [[0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0]] 0 10 1 21 2 33 3 49 4 54 10 21 33 49 54 */&#125;func PrintArr(arr [5]int) &#123; for i:=range arr &#123; //数组是值传递 即使修改了值也改变不了原来的数组内容 if i == 0 &#123; arr[i]= 100 &#125; fmt.Println(arr[i]) &#125; fmt.Println(\"\\n\")&#125; 切片: slice simpleSliceTest.go 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package mainimport \"fmt\"/**Go 语言很重要部分: Slice 1. slice 扩展 2. 向slice添加元素 */func main() &#123; arr := [...]int&#123;2, 23, 392, 22, 9, 4&#125; //半开半闭区间操作: //arr[2:5] --&gt; arr[2] ... arr[4] //故结果: [392 22 9] fmt.Println(arr[2:5]) s1:=arr[2:] fmt.Println(s1) updateArr(s1) fmt.Println(s1) s2:=arr[:] fmt.Println(s2) /** 打印: [392 22 9] [392 22 9 4] [99 22 9 4] [2 23 99 22 9 4] */ //slice 扩展 var sa = []int&#123;0, 1, 2, 3, 4, 5, 6, 7,&#125; fmt.Println(sa) ss1:=sa[2:6] ss2:=ss1[3:5] fmt.Println(\"ss1 : \",ss1) fmt.Println(\"ss2 : \",ss2) /** [0 1 2 3 4 5 6 7] ss1 : [2 3 4 5] ss2 : [5 6] slice 可以向后扩展 不可以向前扩展 s[i] 不可以超越len(s),向后扩展不可以超越底层数组 cap(s) */ //打印相应的 caps fmt.Printf(\"ss1 = %v, len(ss1) = %d , cap(ss1) = %d \\n\",ss1,len(ss1),cap(ss1)) fmt.Printf(\"ss2 = %v, len(ss2) = %d , cap(ss2) = %d \\n\",ss2,len(ss2),cap(ss2)) /** ss1 = [2 3 4 5], len(ss1) = 4 , cap(ss1) = 6 ss2 = [5 6], len(ss2) = 2 , cap(ss2) = 3 */&#125;func updateArr(arr []int) &#123; arr[0]= 99&#125; doSlice.go 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package mainimport \"fmt\"/**操作 slice: 1. append 添加元素 2. copy slice 3. delete one element from slice 4. remove from head and tail */func main() &#123; var arr []int PrintSlice(arr) //arr = [], len(arr) = 0 , cap(arr) = 0 fmt.Println(\"append element\") arr =append(arr, 10,20, 30) PrintSlice(arr) // arr = [10 20 30], len(arr) = 3 , cap(arr) = 4 //手动的创建 slice arr1 :=make([]int, 16) PrintSlice(arr1) //arr = [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], len(arr) = 16 , cap(arr) = 16 arr2 :=make([]int,16, 25) PrintSlice(arr2) //arr = [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], len(arr) = 16 , cap(arr) = 25 fmt.Println(\"copy slice\") copy(arr1, arr) PrintSlice(arr1) //arr = [10 20 30 0 0 0 0 0 0 0 0 0 0 0 0 0], len(arr) = 16 , cap(arr) = 16 fmt.Println(\"delete one element from slice\") //删掉上面的30元素,index =2 arr1=append(arr1[:2],arr1[3:]...) PrintSlice(arr1) //arr = [10 20 0 0 0 0 0 0 0 0 0 0 0 0 0], len(arr) = 15 , cap(arr) = 16 fmt.Println(\"remove from head and tail\") arr1=arr1[1:] PrintSlice(arr1) //arr = [20 0 0 0 0 0 0 0 0 0 0 0 0 0], len(arr) = 14 , cap(arr) = 15 arr1=arr1[:len(arr1)-1] PrintSlice(arr1) //arr = [20 0 0 0 0 0 0 0 0 0 0 0 0], len(arr) = 13 , cap(arr) = 15&#125;func PrintSlice(arr []int) &#123; fmt.Printf(\"arr = %v, len(arr) = %d , cap(arr) = %d \\n\",arr,len(arr),cap(arr))&#125; Map DoGoMap.go 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package mainimport \"fmt\"/**Map : 1.创建方式: 这个是 HashMap 类型 m:=map[string]string&#123;&#125; m:=make(map[string]int) 2.获取元素 3.判断元素是否存在 if 4.删除某个元素 5.range 遍历 6.key 类型: 除了 slice map function 内建类型都可以作为 key struct类型不包含上述字段，也可以作为 key*/func main() &#123; //创建 map m:=map[string]string&#123;&#125; //添加元素 m[\"lai\"]= \"Lai\" m[\"hao\"]= \"Hao\" m[\"da\"]= \"Da\" PrintMap(m) /** lai Lai hao Hao da Da */ //删除元素 delete(m, \"lai\") PrintMap(m) /** hao Hao da Da */ //修改元素 m[\"hao\"]= \"HAhahaha..\" PrintMap(m) /** hao HAhahaha.. da Da */ //判断元素是否存在 key,ok:=m[\"da\"] fmt.Println(key, ok) // Da true if key,ok:=m[\"da\"]; ok &#123; fmt.Println(\"存在此 key \",key) &#125; else &#123; fmt.Printf(\"don't have key %s exist\", key) &#125; //存在此 key Da&#125;func PrintMap(m map[string]string) &#123; for k,v :=range m &#123; fmt.Println(k,v) &#125; fmt.Println(\"\")&#125;","categories":[{"name":"Go","slug":"Go","permalink":"https://zuoyoulai.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://zuoyoulai.github.io/tags/Go/"}],"author":{"nick":"samlai","link":"https://github.com/ZuoYouLai"}},{"title":"每天学习一个 Linux 指令 1  scp","slug":"Linux-scp","date":"2020-01-01T02:55:57.000Z","updated":"2020-01-01T05:04:29.917Z","comments":true,"path":"2020/01/01/Linux-scp/","link":"","permalink":"https://zuoyoulai.github.io/2020/01/01/Linux-scp/","excerpt":"","text":"每天学习一个 Linux 指令 1 : scp 说明 命令格式 12scp [参数] [源路径] [目标路径] 命令参数 实例 复制文件 复制目录 123scp -r local_folder remote_username@remote_ip:remote_folder : 指定了用户名，命令执行后需要输入用户密码 scp -r local_folder remote_ip:remote_folder : 没有指定用户名，命令执行后需要输入用户名和密码 从远程服务器复制到本地服务器 12从远程复制到本地的scp命令与上面的命令雷同，只要将从本地复制到远程的命令后面2个参数互换顺序就行了。 例子 1 : 从远处复制文件到本地目录 1234scp root@192.168.120.204:&#x2F;opt&#x2F;soft&#x2F;nginx-0.5.38.tar.gz &#x2F;opt&#x2F;soft&#x2F;从192.168.120.204机器上的&#x2F;opt&#x2F;soft&#x2F;的目录中下载nginx-0.5.38.tar.gz 文件到本地&#x2F;opt&#x2F;soft&#x2F;目录中 例子 2 : 从远处复制到本地 例子 3 : 上传本地文件到远程机器指定目录 例子 4 : 上传本地目录到远程机器指定目录 例子 5 : 从远处目录到本地指定目录 + ssh key 123456789101112131415161718192021222324A机器无密登录 B 机器的操作: ssh root@ipAddress2台机器 A 本地 B 远程:In A机器：1.yum install ssh2.ssh-keygen -t rsa -C &quot;472023527@qq.com&quot;3.cat ~&#x2F;.ssh&#x2F;id_rsa.pub &#x2F;&#x2F; id_rsa是私钥将这个公钥给机器 B 中In B机器:进入&#x2F;root&#x2F;.ssh&#x2F;目录中 将 A 机器的公钥给复制到 B 器文件 : sam.pub然后执行指令:&gt;&gt; cat sam.pub &gt;&gt; &#x2F;root&#x2F;.ssh&#x2F;authorized_keys (将id_rsa.pub的内容追加到authorized_keys 中)接下来就可以执行 scp 的操作了:scp -r root@192.168.120.204:&#x2F;opt&#x2F;soft&#x2F;mongodb &#x2F;opt&#x2F;soft&#x2F; 参考文章 说明12345678scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来。另外，scp还非常不占资源，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。虽然 rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I&#x2F;O非常高，而scp基本不影响系统正常使用。scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。linux的scp命令可以在linux服务器之间复制文件和目录。 命令格式 格式: 12scp [参数] [源路径] [目标路径] 命令参数 参数:1234567891011121314151617181920212223242526272829303132333435363738scp [参数] [源路径] [目标路径]这里的参数:-1 强制scp命令使用协议ssh1 -2 强制scp命令使用协议ssh2 -4 强制scp命令只使用IPv4寻址 -6 强制scp命令只使用IPv6寻址 -B 使用批处理模式（传输过程中不询问传输口令或短语） -C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能） -p 保留原文件的修改时间，访问时间和访问权限。 -q 不显示传输进度条。 -r 递归复制整个目录。 -v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。 -c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。 -F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。 -i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。 -l limit 限定用户所能使用的带宽，以Kbit&#x2F;s为单位。 -o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式， -P port 注意是大写的P, port是指定数据传输用到的端口号 -S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。 实例复制文件12345678910命令执行后需要输入用户密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名:1. scp local_file remote_username@remote_ip:remote_folder2. scp local_file remote_username@remote_ip:remote_file第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名3. scp local_file remote_ip:remote_folder 4. scp local_file remote_ip:remote_file 复制目录123scp -r local_folder remote_username@remote_ip:remote_folder : 指定了用户名，命令执行后需要输入用户密码 scp -r local_folder remote_ip:remote_folder : 没有指定用户名，命令执行后需要输入用户名和密码 从远程服务器复制到本地服务器12从远程复制到本地的scp命令与上面的命令雷同，只要将从本地复制到远程的命令后面2个参数互换顺序就行了。 例子 1 : 从远处复制文件到本地目录1234scp root@192.168.120.204:&#x2F;opt&#x2F;soft&#x2F;nginx-0.5.38.tar.gz &#x2F;opt&#x2F;soft&#x2F;从192.168.120.204机器上的&#x2F;opt&#x2F;soft&#x2F;的目录中下载nginx-0.5.38.tar.gz 文件到本地&#x2F;opt&#x2F;soft&#x2F;目录中 例子 2 : 从远处复制到本地1234scp -r root@192.168.120.204:&#x2F;opt&#x2F;soft&#x2F;mongodb &#x2F;opt&#x2F;soft&#x2F;从192.168.120.204机器上的&#x2F;opt&#x2F;soft&#x2F;中下载mongodb 目录到本地的&#x2F;opt&#x2F;soft&#x2F;目录来。 例子 3 : 上传本地文件到远程机器指定目录1234scp &#x2F;opt&#x2F;soft&#x2F;nginx-0.5.38.tar.gz root@192.168.120.204:&#x2F;opt&#x2F;soft&#x2F;scptest复制本地opt&#x2F;soft&#x2F;目录下的文件nginx-0.5.38.tar.gz 到远程机器192.168.120.204的opt&#x2F;soft&#x2F;scptest目录 例子 4 : 上传本地目录到远程机器指定目录1234scp -r &#x2F;opt&#x2F;soft&#x2F;mongodb root@192.168.120.204:&#x2F;opt&#x2F;soft&#x2F;scptes上传本地目录 &#x2F;opt&#x2F;soft&#x2F;mongodb到远程机器192.168.120.204上&#x2F;opt&#x2F;soft&#x2F;scptest的目录中去 例子 5 : 从远处目录到本地指定目录 + ssh key123456789101112131415161718192021222324A机器无密登录 B 机器的操作: ssh root@ipAddress2台机器 A 本地 B 远程:In A机器：1.yum install ssh2.ssh-keygen -t rsa -C &quot;472023527@qq.com&quot;3.cat ~&#x2F;.ssh&#x2F;id_rsa.pub &#x2F;&#x2F; id_rsa是私钥将这个公钥给机器 B 中In B机器:进入&#x2F;root&#x2F;.ssh&#x2F;目录中 将 A 机器的公钥给复制到 B 器文件 : sam.pub然后执行指令:&gt;&gt; cat sam.pub &gt;&gt; &#x2F;root&#x2F;.ssh&#x2F;authorized_keys (将id_rsa.pub的内容追加到authorized_keys 中)接下来就可以执行 scp 的操作了:scp -r root@192.168.120.204:&#x2F;opt&#x2F;soft&#x2F;mongodb &#x2F;opt&#x2F;soft&#x2F; 参考文章 来自 : https://www.cnblogs.com/peida/archive/2013/03/15/2960802.html ssh无秘登录的操作 : https://blog.csdn.net/lizhiyuan_eagle/article/details/80494512","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zuoyoulai.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zuoyoulai.github.io/tags/Linux/"}],"author":{"nick":"samlai","link":"https://github.com/ZuoYouLai"}},{"title":"Git使用内容","slug":"Git-md","date":"2019-12-31T09:17:19.000Z","updated":"2019-12-31T09:55:29.769Z","comments":true,"path":"2019/12/31/Git-md/","link":"","permalink":"https://zuoyoulai.github.io/2019/12/31/Git-md/","excerpt":"","text":"Git 使用 添加用户基本信息 删掉本地 Or 远程分支 本地生成 key 写入 GitHub 中 sshkey 方便提交代码 cherry-pick : 只更新某个 commit 的里面内容 回滚到之前某个分支 强行覆盖的最新的内容 备份项目 : 项目同时推送到githhub与coding 添加用户基本信息 可以让本地提交的内容有相应的用户,这样就看 git log 的时候则会出现什么用户提交过了,而不是某个邮箱地址内容提交 123git config --global user.name &quot;xxxx@qq.com&quot;git config --global user.email &quot;xxx@qq.com&quot; 删掉本地 Or 远程分支1234删除分支：git branch -d &lt;name&gt;删除远程分支：git push origin --delete &lt;name&gt; 本地生成 key 写入 GitHub 中 sshkey 方便提交代码 github添加一个ssh key 1234567891011121314Linux:1.yum install ssh2.ssh-keygen -t rsa -C &quot;472023527@qq.com&quot;3.cat ~&#x2F;.ssh&#x2F;id_rsa.pub [复制粘贴到github头像那边的setting再进行添加相应的key值]4.以后进行git操作的代码的时候则不是git https:&#x2F;&#x2F;xxx的方式Windows:1. 安装git，桌面右键点击 &quot;Git Bash&quot;2. cd ~&#x2F;.ssh&#x2F; 3. vi id_rsa.pub 如有 复制内容，在github.com的网站上到ssh密钥管理页面，添加新公钥4. 如没有自行创建公钥 cherry-pick : 只更新某个 commit 的里面内容1234567891011121314151617181920212223将A分支的一个commit合并到B分支： 首先切换到A分支 git checkout A git log 找出要合并的commit ID : 例如 xxx001 然后切换到B分支上 git checkout B git cherry-pick xxx001 然后就将A分支的某个commit合并到了B分支了 回滚到之前某个分支12345678910111213查找对应Log的 id:git log -3 回滚到指定的版本:git reset --hard e377f60e28c8b84158git reset --hard 156d981 强制提交:git push -f origin master 强行覆盖的最新的内容1234567891011121314151617将一个分支覆盖相应的分支: 1.切换到test分支上 git checkout test 2.将master合并到test git merge master 3.将master分支删掉 git branch -d master 4.将test分支覆盖到master分支上 git branch -m test master 5.将master分支推送远程库上[有分支则覆盖 无分支则创建新的分支并更新上去] git push -f origin master 备份项目 : 项目同时推送到githhub与coding 在 CODING 中新建一个同名项目，不选择 启用 README.md 文件初始化项目，以及任何 License 和 .gitignore 文件 在本地项目上添加一个: 123456789101112131415161718 git remote set-url --add origin https:&#x2F;&#x2F;git.coding.net&#x2F;samlai&#x2F;xxx.git ps:项目的根目录.git文件夹下confi配置文件变成[remote &quot;origin&quot;]url &#x3D; https:&#x2F;&#x2F;github.com&#x2F;ZuoYouLai&#x2F;xxx.gitfetch &#x3D; +refs&#x2F;heads&#x2F;*:refs&#x2F;remotes&#x2F;origin&#x2F;*url &#x3D; https:&#x2F;&#x2F;git.coding.net&#x2F;samlai&#x2F;xxx.git[branch &quot;master&quot;]remote &#x3D; originmerge &#x3D; refs&#x2F;heads&#x2F;master指令辅助： (git remote 看看现在项目git 远程主机情况) git remote -v (git remote add 添加一个远程主机) git remote add xx xxx.git (git remote rm xx 删掉远程某个远程的配置内容) 修改本地项目的任意一个文件: 1234git add . git commit -m &#39;test&#39;git push origin master &#x2F;&#x2F; 把本地仓库的变化连接到远程仓库主分支 参考文章: https://feitianbenyue.iteye.com/blog/2376791 https://coding.net/help/doc/git/import.html","categories":[{"name":"Git","slug":"Git","permalink":"https://zuoyoulai.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://zuoyoulai.github.io/tags/Git/"}],"author":{"nick":"samlai","link":"https://github.com/ZuoYouLai"}},{"title":"Go 学习","slug":"Go-Study","date":"2019-12-29T07:20:44.000Z","updated":"2020-01-01T02:37:55.884Z","comments":true,"path":"2019/12/29/Go-Study/","link":"","permalink":"https://zuoyoulai.github.io/2019/12/29/Go-Study/","excerpt":"","text":"GO 语言学习 学习 安装 指令操作 Import 操作： 变量代码 常量 特殊常量 iota 使用 编程 例子1 : Http:HelloWorld 例子2 : 多线程 + 线程间通信 例子3 : 数组的内部排序 例子4 : 单元测试操作 例子5 : 基准测试 学习 指令 : go tool tour 文档 : http://docscn.studygolang.com/doc/ 安装 Linux12345678910111213141516171819202122232425262728下载 &gt; 解压 &gt; 设置下载: wget https:&#x2F;&#x2F;dl.google.com&#x2F;go&#x2F;go1.13.5.linux-amd64.tar.gz 解压: tar -C &#x2F;usr&#x2F;local&#x2F; -xzf go1.13.5.linux-amd64.tar.gz &gt; cd &#x2F;usr&#x2F;local&#x2F;go &gt; bin&#x2F;go version &gt; go version go1.13.5 linux&#x2F;amd64 设置: &gt;&gt; vim &#x2F;etc&#x2F;profile &gt;&gt; 添加到最后如下指令 #go path GOROOT&#x3D;&#x2F;usr&#x2F;local&#x2F;go export PATH&#x3D;$PATH:$GOROOT&#x2F;bin &gt;&gt; 退出 wq ，执行: source % &gt;&gt; go env &#x2F;&#x2F;可以正常打印内容 说明安装成功 GOROOTGOPATHGOBINPATH MacWindows 指令操作12345678910111213141516171819202122go run -v 列出被编译的代码包名称 -a 强制执行 -work 显示临时工作目录并不删除它 -x 打印命令 并执行过它的 -n 打印编译的命令但不执行他们 -p n: 并行编译 其中 n 为并行的数量 go build 编译源码文件或代码包 go install 编译并安装代码或者源码文件查看执行文件:ls $GOBIN go get 从远程代码仓库上下载安装代码包下载到$GOPATH下 第一个文件的的 src文件夹中 -d 只执行下载动作不执行安装动作 -fix 下载后先执行修正动作 再进行编译安装 -U 利用网络来更新已有的代码包及其依赖包 Import 操作： 如果一个 main 导入其他包，包将被顺序导入 如果导入的包依赖其他包(包 B)，会首先导入 B 包，然后初始化 B 包中常量和变量，最后如果 B 包中有 init，会自动执行 init() 如果包导入完成后对 main 中常量和变量进行初始化，执行 main 中的 init函数 如果一个包被导入多次则该包只会被导入一次 import 别名 “.” “_”1234别名：将导入的包命名为另一个容易记忆的别名点操作: .标识的包导入后，调用该包中函数时可以省略前缀包名下划线(_)操作: 导入该包，但不导入整个包，而是执行包中的 init 函数此无法通过包名来调用包中的其他函数 使用下划线操作往往为了注册包中的引擎，让外部可以方便地使用 变量代码 全局变量需要加上 var 方法体内则可以不用加上 大写字母开头可以被包内其他文件导入，小写则不行 常量 类型：显示 隐式1234显式：const identifier [type] &#x3D; value隐式：const identifier &#x3D; value (通常叫无类型常量)常量可以使用内置表达式定义 ： 例如 len() unsafe.Sizeof()常量范围目前只支持布尔，数字，字符串 特殊常量 iota 使用 iota在 const 关键字出现时将被重置为0 const 中每新增一行常量声明将使 iota 计数一次 iota 常见用法12341. 跳值使用法2. 插队使用法3. 表达式隐式使用法4. 单行使用法 编程例子1 : Http:HelloWorld12345678910111213141516package mainimport ( \"fmt\" \"net/http\")func main() &#123; http.HandleFunc(\"/\", func(writer http.ResponseWriter, request *http.Request) &#123; fmt.Fprint(writer,\"Hello World! Mr.Sam赖\") &#125;) http.ListenAndServe(\":8989\",nil)&#125;访问： http://localhost:8989 例子2 : 多线程 + 线程间通信12345678910111213141516171819202122232425package mainimport \"fmt\"func main() &#123; ch :=make(chan string) for i:=0; i&lt;10;i++ &#123; go hello(i, ch) &#125; for &#123; msg :=&lt;-ch fmt.Print(msg) &#125; &#125;func hello(i int,ch chan string) &#123; for &#123; ch &lt;- fmt.Sprintf(\"Hello World...%d \\n \", i) &#125;&#125; 例子3 : 数组的内部排序123456789101112131415package mainimport ( \"fmt\" \"sort\")func main() &#123; //排序 arr:=[]int&#123;45, 23, 6, 12, 1, 905, 16, 75&#125; sort.Ints(arr) for _,val:=range arr &#123; fmt.Println(val) &#125;&#125; 例子4 : 单元测试操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package mainimport \"testing\"/** 1.文件名称必须以: _test 作为后缀 2.忽略测试 t.SkipNow() 3.执行指令: go test -v 4.注意点: 方法名称一定需要 : Test_xxxx 名称 Test 为首字母大写 方法体参数内容 : t *testing.T 5.日志显示: t.Log() t.Error() */func TestRepeat(t *testing.T) &#123; a :=repeat(\"a\") t.Log(\"a 的值\"+ a) k := \"aaaaa\" if a == k &#123; t.Logf(\"测试成功,a 的值为 : %s\",a) &#125;&#125;func TestPk(t *testing.T) &#123; t.Log( t.Name(),\"开始执行 Pt 的内容\") for i:=0;i&lt; 9 ;i++ &#123; repeat(\"a\") &#125;&#125;func repeat(s string) string&#123; var result string for i:=0; i&lt;5 ;i++ &#123; result+= \"a\" &#125; return result&#125;func TestAdd(t *testing.T) &#123; //忽略测试 //t.SkipNow() t.Log(t.Name(), \"Begin....\") a := 2 b := 3 if add(a,b) != 5&#123; t.Errorf(\"result %d \",add(a, b)) &#125; t.Logf(\"a + b is : %d\",add(a,b)) t.Log(t.Name(), \"end....\")&#125;func add(a,b int) int &#123; return a + b&#125;/** go test -v 打印结果：=== RUN TestRepeat--- PASS: TestRepeat (0.00s) lx_test.go:18: a 的值aaaaa lx_test.go:21: 测试成功,a 的值为 : aaaaa=== RUN TestPk--- PASS: TestPk (0.00s) lx_test.go:27: TestPk 开始执行 Pt 的内容=== RUN TestAdd--- PASS: TestAdd (0.00s) lx_test.go:45: TestAdd Begin.... lx_test.go:51: a + b is : 5 lx_test.go:52: TestAdd end....PASS */ 例子5 : 基准测试 参考链接 ： http://c.biancheng.net/view/124.html1234567891011121314151617181920212223242526272829303132/** 参考链接 : http://c.biancheng.net/view/124.html 基准测试: 1.一定需要方法名称 : Benchmark开头 2.执行的指令: go test -v -bench=. go test -v -bench=. jz_test.go 增加自定义时间: go test -v -bench=. -benchtime=5s jz_test.go */func BenchmarkAdd(b *testing.B) &#123; var n int for i:=0;i&lt;b.N;i++ &#123; n++ &#125;&#125;/**执行: go test -v -bench=.打印的内容:goos: darwingoarch: amd64BenchmarkAdd-16 1000000000 0.238 ns/opPASS测试说明：执行了: 1000000000 次每次的操作时间: 0.238 ns*/","categories":[{"name":"Go","slug":"Go","permalink":"https://zuoyoulai.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://zuoyoulai.github.io/tags/Go/"}],"author":{"nick":"samlai","link":"https://github.com/ZuoYouLai"}},{"title":"Linux-Vim 插件,指令的学习","slug":"Linux-Vim","date":"2019-12-26T16:20:02.000Z","updated":"2020-01-01T04:44:58.450Z","comments":true,"path":"2019/12/27/Linux-Vim/","link":"","permalink":"https://zuoyoulai.github.io/2019/12/27/Linux-Vim/","excerpt":"","text":"Vim 编辑器学习 zsh 安装 系统间无密登录 VIM 快捷键 查找 VIm 插件方式 VIm 安装插件 Vim 编辑器学习 学习地址 ： https://www.cnblogs.com/vijozsoft/p/5608108.html vimrc : https://www.cnblogs.com/yuandonghua/p/10483882.html zsh 安装 安装指令: 1sh -c &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;robbyrussell&#x2F;oh-my-zsh&#x2F;master&#x2F;tools&#x2F;install.sh)&quot; 修改主题: https://github.com/ohmyzsh/ohmyzsh/wiki/themes 12345&gt;&gt; vim ~&#x2F;.zshrc主题我喜欢修改成: af-magicZSH_THEME&#x3D;&quot;af-magic&quot;生效:&gt;&gt; exec $SHELL bash和zsh切换 123456切换到bashchsh -s &#x2F;bin&#x2F;bash切换到zshchsh -s &#x2F;bin&#x2F;zsh 卸载oh my zsh : Mac 参考链接 : https://my.oschina.net/u/2391658/blog/1584566 1在命令行输入如下命令，回车即可：uninstall_oh_my_zsh 系统间无密登录123456789101112131415161718A机器无密登录 B 机器的操作: ssh root@ipAddress2台机器 A 本地 B 远程:In A机器：1.yum install ssh2.ssh-keygen -t rsa -C &quot;472023527@qq.com&quot;3.cat ~&#x2F;.ssh&#x2F;id_rsa.pub &#x2F;&#x2F; id_rsa是私钥将这个公钥给机器 B 中In B机器:进入&#x2F;root&#x2F;.ssh&#x2F;目录中 将 A 机器的公钥给复制到 B 器文件 : sam.pub然后执行指令:&gt;&gt; cat sam.pub &gt;&gt; &#x2F;root&#x2F;.ssh&#x2F;authorized_keys (将id_rsa.pub的内容追加到authorized_keys 中) VIM 快捷键基本使用 [ shift + : ] : 进入 normal 模式 [ i ] : 插入编写操作 –&gt; insert操作 [ a ] : append在光标处添加模式 [ wq ] : 书写+退出操作 [ q ] :退出 [ !q ] :强制退出操作 [ esc 或者 control + [ ] : 插入模式转为 normal模式 光标移动 Ctrl + u 【往前翻页】 Ctrl + f 【往前翻页 : forward】 gg : 第一行 GG : 最后一行 0 : 行首 $ : 行尾 V : 选中行内容 使用 k j 来选中内容 h : 向左 j ：向下 k : 向上 l : 向右 0 : 回到行首 $ : 回到行尾 gg : 回到行首 G : 回到行尾 u : 返回上一步 control + r : 重复上一步的操作 插入字符 i a I : 回到行头进行插入 A: 进入光标所对应的行尾插入 p : 粘贴 yy ：复制一行 删除字符 x : 向后删除单个字符 X : 向前删除单个字符 nx，nX : 删除多个字符的操作 打开文件 vim 1.txt 2.txt -O 查找 VIm 插件方式 google 的方式 浏览: vimawesome.com : https://vimawesome.com/ VIm 安装插件插件工具 : vim-plugin 插件工具内容：vim-plugin : https://github.com/junegunn/vim-plug12345678910mac 系统执行:curl -fLo ~&#x2F;.vim&#x2F;autoload&#x2F;plug.vim --create-dirs \\ https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;junegunn&#x2F;vim-plug&#x2F;master&#x2F;plug.vim编写添加内容到 vimrc:call plug#begin(&#39;~&#x2F;.vim&#x2F;plugged&#39;)call plug#end() 浏览最近插件: vim-startify 安装浏览最近的文件的插件: vim-startify : https://github.com/mhinz/vim-startify123456789101112131415Plug &#39;mhinz&#x2F;vim-startify&#39;编写添加内容到 vimrc:&gt;&gt; vim ~&#x2F;.vimrccall plug#begin(&#39;~&#x2F;.vim&#x2F;plugged&#39;)Plug &#39;mhinz&#x2F;vim-startify&#39;call plug#end()然后让 vimrc 进行生效：进入 vim ~&#x2F;.vimrc 的 normal 模式 执行2个指令：:source ~&#x2F;.vimrc:PluginInstall插件就可以成功安装：然后执行 vim 就可以查看就近打开的文件内容 代码补全的插件：vim-surround 代码补全的插件：surround : https://github.com/tpope/vim-surround1234567891011Plug &#39;tpope&#x2F;vim-surround&#39;使用方式:ds (delete a surrounding)cs (change a surrounding)ys (you add a surrounding)光标在单词的左处:ds iw &#39; --&gt; 将字符添加一个单引号cs &#39; &quot; --&gt; 将字符的单引号变成双引号ds &quot; --&gt; 删除&quot;引号 状态栏美化: vim-airline 状态栏美化: vim-airline : https://github.com/vim-airline/vim-airline 12Plug &#39;vim-airline&#x2F;vim-airline&#39;Plug &#39;vim-airline&#x2F;vim-airline-themes&#39; 代码缩进线条:indentline 代码缩进线条:indentline 1Plug &#39;yggdroot&#x2F;indentline&#39; 配色: vim-hybrid 配色: vim-hybrid: https://github.com/w0ng/vim-hybrid12345678Plug &#39;w0ng&#x2F;vim-hybrid&#39;其他配置加上vimrc:set background&#x3D;darkcolorscheme hybrid 【本地安装了：Oh My Zsh 】 需要修改相应的主题：https:&#x2F;&#x2F;github.com&#x2F;ohmyzsh&#x2F;ohmyzsh&#x2F;wiki&#x2F;themesvim ~&#x2F;.zshrcZSH_THEME&#x3D;&quot;af-magic&quot; 树形文件目录 : nerdtree 树形文件夹管理:12345678910111213141516171819202122232425262728293031323334 Plug &#39;scrooloose&#x2F;nerdtree&#39; 添加 Ctrl+n 方式:(vimrc) map &lt;C-n&gt; :NERDTreeToggle&lt;CR&gt; 配合使用 Normal 方式操作： Ctrl+n 打开树结构 :vs 打开新的窗体 ctrl+w+w 光标在左右窗口切换 快捷键： 参考链接内容: https:&#x2F;&#x2F;blog.csdn.net&#x2F;Lius_1006&#x2F;article&#x2F;details&#x2F;79524512 h j k l移动光标定位 ctrl+w+w 光标在左右窗口切换 ctrl+w+r 切换当前窗口左右布局 ctrl+p 模糊搜索文件 gT 切换到前一个tab g t 切换到后一个tab o 打开关闭文件或者目录，如果是文件的话，光标出现在打开的文件中 O 打开结点下的所有目录 X 合拢当前结点的所有目录 x 合拢当前结点的父目录 i和s水平分割或纵向分割窗口打开文件 u 打开上层目录t 在标签页中打开 T 在后台标签页中打开 p 到上层目录 P 到根目录 K 到同目录第一个节点 J 到同目录最后一个节点 m 显示文件系统菜单（添加、删除、移动操作） ? 帮助 :q 关闭 快速定位文件:ctrlp 快速定位文件:ctrlp : https://github.com/kien/ctrlp.vim 1234Plug &#39;kien&#x2F;ctrlp.vim&#39;添加快捷键：let g:ctrlp_map &#x3D; &#39;&lt;c-p&gt;&#39; 快速查找文件字符 ：easymotion 快速查找文件字符 ：easymotion https://github.com/easymotion/vim-easymotion 1234567Plug &#39;easymotion&#x2F;vim-easymotion&#39;添加快捷键：nmap ss &lt;Plug&gt;(easymotion-s2)可能安装的插件的时间比较长 需要等下使用的方式:按下 ss 键 写入单个字符 就可以全文查找 根据某个特定的字符来跳到相应的位置上 模糊搜索：fzf 模糊搜索 : https://github.com/junegunn/fzf.vim 123456Plug &#39;junegunn&#x2F;fzf&#39;, &#123; &#39;dir&#39;: &#39;~&#x2F;.fzf&#39;, &#39;do&#39;: &#39;.&#x2F;install --all&#39; &#125;Plug &#39;junegunn&#x2F;fzf.vim&#39;常用指令::Files [PATH] 查找文件名称的搜索:Ag [PATTERN] 查找文件字符的搜索 全局替换: far 全局替换: https://github.com/brooth/far.vim 1234Plug &#39;brooth&#x2F;far.vim&#39;:Far foo bar **&#x2F;*.py:Fardo go 语言代码的书写: vim-go github : https://github.com/fatih/vim-go 说明文档 : https://github.com/fatih/vim-go-tutorial 123Plug &#39;fatih&#x2F;vim-go&#39;, &#123; &#39;do&#39;: &#39;:GoUpdateBinaries&#39; &#125;指令使用: 注释内容插件：vim-commentary 注释内容: https://github.com/tpope/vim-commentary 123456Plug &#39;tpope&#x2F;vim-commentary&#39;使用 gc 进行注释选择多行进行注释操作::V j k (向上向下选取内容) + gc 就可以进行多行注释(任何语言都是可以进行注释的)","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zuoyoulai.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zuoyoulai.github.io/tags/Linux/"},{"name":"Vim","slug":"Vim","permalink":"https://zuoyoulai.github.io/tags/Vim/"}],"author":{"nick":"samlai","link":"https://github.com/ZuoYouLai"}},{"title":"docker笔记内容","slug":"docker笔记内容","date":"2019-12-25T07:25:03.000Z","updated":"2019-12-29T16:40:03.219Z","comments":true,"path":"2019/12/25/docker笔记内容/","link":"","permalink":"https://zuoyoulai.github.io/2019/12/25/docker%E7%AC%94%E8%AE%B0%E5%86%85%E5%AE%B9/","excerpt":"","text":"Docker 学习笔记内容 docker-swarm: Docker 学习笔记内容 jdk 与 docker各种版本之间限制:【很好的博文 来自】 12345678简言之：注意资源限制的不匹配。测试你的内存设置和JVM标志，不要假设任何东西。如果您在Docker容器中运行Java，请确保你设置了docker内存限制和在JVM中也做了限制，或者你的JVM能够理解这些限制。如果您无法升级您的Java版本，请使用-Xmx设置您自己的限制。对于Java 8和Java 9，请更新到最新版本并使用： -XX：+UnlockExperimentalVMOptions -XX：+UseCGroupMemoryLimitForHeapdocker run -m 100m -it adoptopenjdk&#x2F;openjdk10:nightly &#x2F;bin&#x2F;bash对于Java 10，确保它支持’UseContainerSupport’（更新到最新版本）。docker run -m 100m -it adoptopenjdk&#x2F;openjdk9-openj9 &#x2F;bin&#x2F;bash对于OpenJ9（我强烈建议使用，可以在生产环境中有效减少内存占用量），现在使用-Xmx设置限制，但很快会出现一个支持UseContainerSupport标志的版本。 1.配置的docker容器,外网不可以访问，只能内网才可以进行访问 12docker run xxx -p 3306:3306 -d xximage : 这个port会对外网可以进行访问,无视防火墙的设置docker run xxx -p 127.0.0.1:3306:3306 -d xximage : 这个port是针对本地的地址的内容，外网无法进行访问 2.清空的none的docker镜像内容 1docker rmi $(docker images -f &quot;dangling&#x3D;true&quot; -q) 3.docker可视化工具:portainer 参考资料 | 官方文档 1234567891011121314151617181920212223242526272829303132333435 1.拉取镜像：docker pull portainer&#x2F;portainer 2.docker run相应的脚本内容： local本地模式开启: 添加 ： -v &quot;&#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock&quot; docker run -d -p 9000:9000 \\ --restart&#x3D;always \\ -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock \\ --name prtainer-test \\ docker.io&#x2F;portainer&#x2F;portainer 3.访问相应的ip地址：http:&#x2F;&#x2F;IP:9000 &#96;&#96;&#96; - 4.docker无法查看jvm的参数 [参考资料](https:&#x2F;&#x2F;blog.csdn.net&#x2F;kinginblue&#x2F;article&#x2F;details&#x2F;78078028)&#96;&#96;&#96;text 1.使用 --cap-add 明确添加指定功能： docker run --cap-add&#x3D;SYS_PTRACE ... 2.docker compose添加的相应指令: version: &#39;2&#39; services: mysql: ... api: ... cap_add: - SYS_PTRACE &#96;&#96;&#96; - 5.docker对jdk资源的限制: [参考资料](https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000014142950)- 6.docker compose指令 : [参考资料](https:&#x2F;&#x2F;www.cnblogs.com&#x2F;52fhy&#x2F;p&#x2F;5991344.html) - 7.docker容器启动非常的缓慢 死机 [参考](https:&#x2F;&#x2F;my.oschina.net&#x2F;u&#x2F;1188877&#x2F;blog&#x2F;422405?p&#x3D;1)&#96;&#96;&#96;text 1.sudo service docker stop 2.rm -rf &#x2F;var&#x2F;lib&#x2F;docker&#x2F;* #(记得备份重要数据) 3.sudo servie docker start 8.linux报错:kernel:unregister_netdevice: waiting for lo to become free. Usage count = 1 docker-compose12docker-compose up 执行docker镜像的内容docker-compose build 会执行文件里面需要build的镜像内容,然后再进行up的处理 docker-swarm:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374751.生产环境的使用，多机器，扩展部署2.Node有2种角色：Manager Worker3.Manager要多节点部署避免单点故障 需要共享库来同步状态4.Service 和 Replicas5.Manager进行做决策多部署服务到多个节点上 6.docker swarm 指令: A.docker swarm --advertise-addr&#x3D;[IP] 初始化manager 查看join的信息然后把内容加入到子节点上 B.docker node ls 查看manager节点信息 看到manger+worker的节点信息7.swarm环境搭建好之后，进行对service进行操作 A.创建服务: docker service create -name [Images] bash B.docker service ls C.docker service ps demo D.docker service scale&#x3D;[Num] 水平扩展到不一样的机器8.docker swarm部署 wordpress A.创建网络：共享的网络 docker network create -d overlay demo B.docker service create xxxName C.多节点的同步问题：overlay : 原理是DNS服务来发现的功能，为连overlay建一条日志 docker swarm技术: Routing Mesh的两种体现：【题外话：Lvs+keepalived实现高可用集群】 A. Internal : container 和 container之间的访问通过overlay网络(通过Vip虚拟Ip) 【具体原理可以查看 [图片](&#x2F;images&#x2F;Internal原理.png)】 B. Ingress ： 如果服务有绑定接口，则此服务可以通过任意swarm节点的相应接口访问 作用: 外部访问的负载均衡 服务端口被暴露到各个swarm节点 内部通过IpVs进行负载均衡 [Ingress流程图 ： &#x2F;images&#x2F;Ingress.png] [数据包传输流程图 ： &#x2F;images&#x2F;Ingress数据包走向.png] 9.docker发布服务在生产环境: 借助compose 的 version &#x3D; 3部署到生产环境上 docker stack deploy 执行的compose文件的内容 docker stack remove 进行删掉的services服务 10.DOckerSecret管理 Secret Management: 1.存在Swarm Manager节点Raft database里 2.Secret可以assign给一个service,这个service就能看到这个secret 3.在container内部secret看起来像文件，但是实际上在内存中 指令: 创建: docker secret create my-pwd 删除: docker secret rm my-pwd 在创建一个secret在一个容器中，容器里面的文件夹中有相应的内容： 1. docker service create --name xxx --secret my-pwd 【imagesName】 2. docker service ls 查看服务节点多少个 3. docker service ps [name] 查看服务节点在哪里 4. cat &#x2F;run&#x2F;secrests&#x2F;my-pwd 就可以查看secret的明文内容 11.Swarm更新服务(生产环境): A.运行一个service docker service create --name web --publish 8080:5000 --network demo flask:1.0 B.运行2个节点的操作 docker service scale web&#x3D;2 3.运行shell指令来测试 sh -c &quot;while true; do curl 127.0.0.1:8080&amp;&amp;sleep 1;done&quot; 4.更新指令很多内容: docker service update --help 5.更新images的版本 docker service update --image flask:2.0 web 6.更新端口的操作:删掉原来的端口并添加新的端口操作 docker service ps web docker service update --publish-rm 8080:5000 --publish-add 8099:5000 web 12. dockerEE 企业版:可以查看swarm部署多个节点监控状态 在dockerEE基础上部署DTR,其作用是扫描镜像的安全性问题 阿里云也有相应的docker-swarm服务，但是相应的付费还是蛮昂贵的 替代Docker Compose实现容器双向联通的三种方法","categories":[{"name":"Docker","slug":"Docker","permalink":"https://zuoyoulai.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://zuoyoulai.github.io/tags/Docker/"}],"author":{"nick":"samlai","link":"https://github.com/ZuoYouLai"}},{"title":"windows-Mq 启动操作","slug":"windows-Mq","date":"2019-12-25T06:08:48.000Z","updated":"2019-12-29T16:40:03.227Z","comments":true,"path":"2019/12/25/windows-Mq/","link":"","permalink":"https://zuoyoulai.github.io/2019/12/25/windows-Mq/","excerpt":"","text":"Windows RocketMq Console管理控制台的启动 启动的脚本 访问 Windows RocketMq Console管理控制台的启动下载 &amp; 打包123git clone https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;rocketmq-externals.gitcd rocketmq-externals&#x2F;rocketmq-console&#x2F;mvn clean package -Dmaven.test.skip&#x3D;true 启动的脚本 3.5版本以下 1java -jar target\\rocketmq-console-ng-1.0.1.jar --rocketmq.config.namesrvAddr&#x3D;127.0.0.1:9876 &gt; log.txt --rocketmq.config.isVIPChannel&#x3D;false 3.5版本以下 1java -jar target\\rocketmq-console-ng-1.0.1.jar --rocketmq.config.namesrvAddr&#x3D;127.0.0.1:9876 &gt; log.txt 还有其他的配置可以自定义配置的：【以下配置来自console项目的 application.properties】 1234567891011121314151617181920212223242526272829server.contextPath&#x3D;server.port&#x3D;8080### SSL setting#server.ssl.key-store&#x3D;classpath:rmqcngkeystore.jks#server.ssl.key-store-password&#x3D;rocketmq#server.ssl.keyStoreType&#x3D;PKCS12#server.ssl.keyAlias&#x3D;rmqcngkey#spring.application.index&#x3D;truespring.application.name&#x3D;rocketmq-consolespring.http.encoding.charset&#x3D;UTF-8spring.http.encoding.enabled&#x3D;truespring.http.encoding.force&#x3D;truelogging.config&#x3D;classpath:logback.xml#if this value is empty,use env value rocketmq.config.namesrvAddr NAMESRV_ADDR | now, you can set it in ops page.default localhost:9876rocketmq.config.namesrvAddr&#x3D;#if you use rocketmq version &lt; 3.5.8, rocketmq.config.isVIPChannel should be false.default truerocketmq.config.isVIPChannel&#x3D;#rocketmq-console&#39;s data path:dashboard&#x2F;monitorrocketmq.config.dataPath&#x3D;&#x2F;tmp&#x2F;rocketmq-console&#x2F;data#set it false if you don&#39;t want use dashboard.default truerocketmq.config.enableDashBoardCollect&#x3D;true#set the message track trace topic if you don&#39;t want use the default onerocketmq.config.msgTrackTopicName&#x3D;rocketmq.config.ticketKey&#x3D;ticket#Must create userInfo file: $&#123;rocketmq.config.dataPath&#125;&#x2F;users.properties if the login is requiredrocketmq.config.loginRequired&#x3D;false 如果出错的话则查看log.txt文件内容 访问访问URL : http://localhost:8080/ 正确启动","categories":[{"name":"Mq","slug":"Mq","permalink":"https://zuoyoulai.github.io/categories/Mq/"},{"name":"Rocketmq","slug":"Mq/Rocketmq","permalink":"https://zuoyoulai.github.io/categories/Mq/Rocketmq/"}],"tags":[{"name":"Rocketmq","slug":"Rocketmq","permalink":"https://zuoyoulai.github.io/tags/Rocketmq/"}],"author":{"nick":"samlai","link":"https://github.com/ZuoYouLai"}},{"title":"借鉴博客学习","slug":"借鉴博客学习-md","date":"2019-12-25T02:27:44.000Z","updated":"2020-01-07T08:31:48.055Z","comments":true,"path":"2019/12/25/借鉴博客学习-md/","link":"","permalink":"https://zuoyoulai.github.io/2019/12/25/%E5%80%9F%E9%89%B4%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0-md/","excerpt":"优秀文章内容 文档 博客内容 优秀文章内容 权威文档 优秀笔记内容 个人博客","text":"优秀文章内容 文档 博客内容 优秀文章内容 权威文档 优秀笔记内容 个人博客 文档 名称 Url 互联网扫盲笔记 https://doocs.github.io/advanced-java/#/ 下载资源网盘 https://m.pantianxia.com/ 下载资源 http://www.xiazaij.com/author/xiazaij/ zlnnjit(博客一直在持续的更新) https://www.bcoder.top/ jboot https://jboot.io/ 鸟哥私房菜 http://cn.linux.vbird.org/linux_basic/linux_basic.php k8s http://kubernetes.kansea.com/docs/hellonode/ 唯品会开发手册 https://vipshop.github.io/vjtools/#/standard/ leecode编程算法网站 https://leetcode-cn.com/problemset/all/ 许雪里开源列表 http://www.xuxueli.com/page/projects.html 代码有毒的笔记 https://zq99299.github.io/note-book/ ES权威指南笔记 http://blog.didispace.com/books/elasticsearch-definitive-guide-cn/ Cyc2018笔记脑图 http://naotu.baidu.com/file/b49ccc722da46972dfe3a720cd414a11 Java虚拟机：JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解 https://www.fangzhipeng.com/javainterview/2019/04/17/jvm-tools.html Shiro用starter方式优雅整合到SpringBoot中 比较全面的 https://segmentfault.com/a/1190000014479154?utm_source=index-hottest rocketMq的笔记内容 https://www.bcoder.top/2017/12/17/%E4%B8%9A%E4%BD%99%E5%AD%A6%E4%B9%A0%E4%B9%8BRocketMQ%E4%B8%AD%E7%BA%A7%E7%AF%87/#%E6%B6%88%E8%B4%B9%E8%80%85%E6%B6%88%E6%81%AF%E9%87%8D%E8%AF%95 容器面试笔记 http://www.spring4all.com/article/6786 阿飞的博客 https://www.jianshu.com/u/6779ec81d3b7 正则表达式学习 http://blog.didispace.com/regular-expression-all/ 【课程】Elastic Stack入门与实践 https://www.imooc.com/article/45855 【课程】Elastic Stack入门与实践 [描述的较好] https://blog.csdn.net/hiwes/article/category/8448094 【课程】JVM笔记内容 http://www.imooc.com/article/details/id/251567#param-type jdk各个版本间docker兼容问题 https://kelvinji2009.github.io/tags/docker/ k8s开启 https://kelvinji2009.github.io/blog/kubernetes-bible-beginners/ 【课程】Nginx入门到实践 https://www.jianshu.com/nb/32398790 【极客时间】从0开始学架构【笔记】 https://zhimap.com/mhtml/6159a37f642c480e984e9ad5d97e2489 IO流读取的比较 https://www.cnkirito.moe/file-io-best-practise/ 使用Redis的分布式锁 https://wudashan.cn/2017/10/23/Redis-Distributed-Lock-Implement/ ##特指权威性的网站名称 | Url——|—–elasticsearch日报 | https://elasticsearch.cn/docker中文文档 | https://docs.docker-cn.comdocker中文论坛社区 | http://dockone.io/jenkins官方的文档内容 | https://jenkins.io/zh/sharding-jdbc官方中文文档 | https://shardingsphere.apache.org/document/current/cn/overview/docker-file 良好的实践 | https://juejin.im/entry/5d2405be6fb9a07f091bc7f3?utm_source=gold_browser_extension 博客内容 名称 Url ASM获取参数 https://www.cnblogs.com/relucent/p/6525821.html 书籍的推荐 https://blog.csdn.net/u011896537/article/details/89467774 mrbird[很多java的干货] https://mrbird.cc/ [小窝小窝] https://z77z.oschina.io/ 死磕java[文章非常的全面系统] http://cmsblogs.com/?page_id=3027 猿天地 http://cxytiandi.com/article 周立博客[springboot + springcloud教程 书作者] http://www.itmuch.com/ 程序员DDD [springboot + springcloud教程 书作者] http://blog.didispace.com/ 方志朋[spring cloud教程] https://www.cnblogs.com/forezp/category/1327932.html 方志朋[spring cloud + java + 架构] https://www.fangzhipeng.com 纯洁的微笑[springboot + springcloud教程] http://www.ityouknow.com/ java知音[java基础 面试 web 各种java基础 算法] https://www.javazhiyin.com 匠心零度[jvm rocketmq] http://www.jiangxinlingdu.com/ anoyi[k8s docker-swarm 还有书籍的下载] https://anoyi.com Loull[蛮坚持写博客的人 实用性还是蛮高的] https://www.cnblogs.com/549294286/ 叶落[Nginx NIO资料不是很多] http://www.liqinghe.com/technology.html 技术栈蛮深,涉略spring redis boot https://www.cnblogs.com/hujunzheng 不折腾会死 (shiro 文章可能较少) https://segmentfault.com/blog/die4zhe [阿里数据库内核主管] http://hedengcheng.com/?p=771 [core java] http://www.carlzone.cn [数据结构] http://timd.cn [架构分布式] http://www.kailing.pub [一个未毕业却很努力却很强技术栈学生] https://www.cnblogs.com/yueshutong/ [java 高级知识点：rocketmq 分布式事务 分布式锁] https://www.jianshu.com/u/bbe9e62bc5ba spring4all http://www.spring4all.com/ Hollis https://www.hollischuang.com/ 梁桂钊 http://blog.720ui.com/columns/springboot_all/ 码小猪 https://www.hchstudio.cn 若鱼 https://blog.csdn.net/goldenfish1919 许雪里 http://www.xuxueli.com/blog/#/?id=%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80 py教师+容器化视频的讲师 http://www.imooc.com/t/5634820 代码有毒 https://blog.csdn.net/mr_zhuqiang 屈定 https://mrdear.cn/ 吾爱程序员 https://www.52programer.com/ 代码有毒的笔记博客 https://zq99299.github.io/note-book/ 代码有毒的CSDN https://blog.csdn.net/mr_zhuqiang kelvinji2009[很牛的人] https://kelvinji2009.github.io/ 运维的笔记 http://www.zsythink.net/ 技术颜良[文章很有水准] https://www.cnblogs.com/cheyunhua/p/?page=32 Java知识分享[下载pdf文章] http://www.java1234.com/ 芋道源码[各种java源码解析] http://www.iocoder.cn/ 空挡 网络 rocketmq https://www.jianshu.com/u/d00590abcb80 [es springboot flink] http://www.54tianzhisheng.cn 架构研究 http://www.shinians.com/html/blog.html 人工智能 https://www.captainbed.net/mengday/ Hexo博客安装 https://y0ngb1n.github.io/","categories":[{"name":"学习文章","slug":"学习文章","permalink":"https://zuoyoulai.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"学习文章","slug":"学习文章","permalink":"https://zuoyoulai.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0/"},{"name":"GitHub","slug":"GitHub","permalink":"https://zuoyoulai.github.io/tags/GitHub/"}],"author":{"nick":"samlai","link":"https://github.com/ZuoYouLai"}},{"title":"我的 Hexo 博客系统的搭建","slug":"hexo-study-md","date":"2019-12-24T15:50:00.000Z","updated":"2019-12-29T16:40:03.229Z","comments":true,"path":"2019/12/24/hexo-study-md/","link":"","permalink":"https://zuoyoulai.github.io/2019/12/24/hexo-study-md/","excerpt":"","text":"搭建个人博客站点 Mac 环境系统搭建博客 Linux 环境系统搭建博客 git 发布的插件 添加 hexo 文章目录插件 ### 搭建个人博客站点 + 本地 Linux 需要安装 : Git + 本地 Mac 安装 node ：https://nodejs.org/en/download/ Mac 环境系统搭建博客 mac 安装 node 权限的问题,解决问题链接：https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally 1234567891011121314151617181920212223242526会出现 root 与 本地用户操作权限的问题，如：npm install -g xxx 操作的需要做出如下操作:&gt;&gt; mkdir ~&#x2F;.npm-global&gt;&gt; npm config set prefix &#39;~&#x2F;.npm-global&#39;&gt;&gt; vim ~&#x2F;.bash_profile添加如下：export PATH&#x3D;&#x2F;Users&#x2F;haodalai&#x2F;.npm-global&#x2F;bin:$PATHexport PATH&#x3D;&#x2F;Users&#x2F;haodalai&#x2F;Blog&#x2F;node_modules&#x2F;.bin:$PATH&gt;&gt; echo $PATH&gt;&gt; source ~&#x2F;.bash_profile &gt;&gt; npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org （测试是 ok 的）mac 安装 hexo：路径设置：&gt;&gt; export PATH&#x3D;~&#x2F;Blog&#x2F;node_modules&#x2F;.bin:$PATH&gt;&gt; echo $PATH&gt;&gt; hexo （测试生效）新建一个hexo 项目&gt;&gt; mkdir ~&#x2F;Blog&#x2F;Samlai-Blog&gt;&gt; hexo init ~&#x2F;Blog&#x2F;Samlai-Blog&gt;&gt; Linux 环境系统搭建博客 Linux 参考 Hexo 文档来进行搭建博客站点： https://hexo.io/zh-cn/docs/12345678910111213141516171819202122232425261. 安装 nodejs 使用这种方式来安装 : Linux（DEB&#x2F;RPM-based）：从 NodeSource 安装 参考链接 ： https:&#x2F;&#x2F;github.com&#x2F;nodesource&#x2F;distributions 因为本地是 centos 执行指令 : &gt;&gt; curl -sL https:&#x2F;&#x2F;rpm.nodesource.com&#x2F;setup_12.x | bash - 执行完成后: &gt;&gt; sudo yum install -y nodejs 2. 使用淘宝镜像 cnpm : &gt;&gt; npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org 3. 使用 npm 安装 hexo: &gt;&gt; cnpm install hexo 4. 将 Hexo 所在的目录下的 node_modules 添加到环境变量之中即可直接使用 hexo &lt;command&gt;： &gt;&gt; echo &#39;PATH&#x3D;&quot;$PATH:&#x2F;opt&#x2F;hexo&#x2F;node_modules&#x2F;.bin&quot;&#39; &gt;&gt; ~&#x2F;.profile 注意: 我安装hexo 目录到我的系统路径为 : &#x2F;opt&#x2F;hexo 执行上面没有效果的话，无法识别 hexo 指令的话，则可以直接修改 ： vim &#x2F;etc&#x2F;profile 文件 文件最后面写上: HEXO_HOME&#x3D;&#x2F;opt&#x2F;hexo&#x2F;node_modules&#x2F;.bin PATH&#x3D;$PATH:$HEXO_HOME 使用 HEXO 创建项目123456789101112131. 初始化 hexo 项目hexo init &#x2F;opt&#x2F;blog2. 生成静态文件hexo generate3.运行服务器hexo server4.创建文件内容hexo new post 借鉴博客学习.md 修改 hexo 的主题与发布12345678910111213141516171819202122232425262728293031323334353637381. 注册一个 githhub 账号 并建一个名称为： xxx(你的 github 账号).github.io 项目2. 在服务新建一个github ssh key: 1.yum install ssh 2.ssh-keygen -t rsa -C &quot;472023527@qq.com&quot; 3.cat ~&#x2F;.ssh&#x2F;id_rsa.pub [复制粘贴到github头像那边的setting再进行添加相应的key值] 4.以后进行git操作的代码的时候则不是git https:&#x2F;&#x2F;xxx的方式 5.创建全局的 git 账号: [hexo d 执行的时候会报错] git config --global user.email &quot;472023527@qq.com&quot; git config --global user.name &quot;samlai&quot; 3. 拉取主题内容: cd &#x2F;opt&#x2F;blog git clone https:&#x2F;&#x2F;github.com&#x2F;litten&#x2F;hexo-theme-yilia.git themes&#x2F;yilia 4. 修改 hexo 的发布的方式： vim _config.yml 修改发布方式: deploy: type: git repository: git@github.com:ZuoYouLai&#x2F;ZuoYouLai.github.io.git branch: master 修改主题内容： themes: yilia 5. 安装 hexo 的 git 插件 : cnpm install hexo-deployer-git --save 6. 执行 hexo 发布执行操作： hexo d (hexo deploy) hexo s (hexo server) hexo 与 github.io 共同的发布操作12345github.io 的文件都是为：本地执行 hexo d 指令编译成静态文件然后并上传到 github.io 的仓库中.所以可以访问 https:&#x2F;&#x2F;zuoyoulai.github.io&#x2F; 可以直接访问静态文件 html 内容项目的保存最好存 md 文件的 github 的仓库的，每次写完自己新的笔记 md 文件后，提交github 仓库为了备份 md 文件内容。保存好 md 文件后再在本地执行：hexo -d 【编译好静态文件并上传到 github.io 的仓库上】 git 发布的插件1cnpm install hexo-deployer-git --save 添加 hexo 文章目录插件1234cnpm install hexo-toc --save在文章标题下添加：&lt;!-- toc --&gt; 本文参考 https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html https://www.jianshu.com/p/1bcad7700c46","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zuoyoulai.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://zuoyoulai.github.io/tags/Hexo/"}],"author":{"nick":"samlai","link":"https://github.com/ZuoYouLai"}}]}